<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hdheid&#39;s blog</title>
  
  <subtitle>青春须早为，岂能长少年。</subtitle>
  <link href="https://hdheid.github.io/atom.xml" rel="self"/>
  
  <link href="https://hdheid.github.io/"/>
  <updated>2022-09-06T08:51:18.958Z</updated>
  <id>https://hdheid.github.io/</id>
  
  <author>
    <name>Hdheid</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>2022-09-06队列队每日一题</title>
    <link href="https://hdheid.github.io/posts/24cf2cc2.html"/>
    <id>https://hdheid.github.io/posts/24cf2cc2.html</id>
    <published>2022-09-06T08:47:07.870Z</published>
    <updated>2022-09-06T08:51:18.958Z</updated>
    
    <content type="html"><![CDATA[<div class="tag link"><a class="link-card" title="力扣 828. 统计子串中的唯一字符" href="https://leetcode.cn/problems/count-unique-characters-of-all-substrings-of-a-given-string/"><div class="left"><img src="https://img.hipyt.cn/imgs/2022/09/e3f773cfe32f6f4f.jpg"/></div><div class="right"><p class="text">力扣 828. 统计子串中的唯一字符</p><p class="url">https://leetcode.cn/problems/count-unique-characters-of-all-substrings-of-a-given-string/</p></div></a></div><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>给出字符串 s，假设 str 为 s 的一个字数组，sum 为 str 中单个字符的数量(<span class='p red'>只出现过一次的字母</span>)。求出 s 的所有子字符串的 sum 的总和。</p><h2 id="题意解析"><a href="#题意解析" class="headerlink" title="题意解析"></a>题意解析</h2><div class="tip info"><p>参考题解：<a href="https://leetcode.cn/problems/count-unique-characters-of-all-substrings-of-a-given-string/solution/c-you-li-zi-yi-dong-by-smilyt_/">https://leetcode.cn/problems/count-unique-characters-of-all-substrings-of-a-given-string/solution/c-you-li-zi-yi-dong-by-smilyt_/</a></p></div><p>对于这个题目，我们不能够被题目误导，我们从每一个字母来看，<span class='p red'>看每一个字母能够有效的出现在多少个子字符串中</span>，我们称其为这个字母的<span class='p red'>贡献</span>。那么我们只需要求出所有的字母的贡献即可。</p><blockquote><p>对于某一个字母的贡献，我们先找出其有效的区间(<strong>区间内只包含一个该字符</strong>)，假设区间为 <strong>[ l , r ] </strong>，该字母在位置 i ( <strong>l &lt;= i &lt;= r</strong> ) 处。那么由排列组合可以知道，其贡献为：<strong>( i - l )x( r - i )</strong>。也就是 该字母左边的单词个数(加上该字母) 乘 该字母右边的单词个数(不包括该字母)。</p><p>怎么求有效区间？<br>我们用 l [N] 数组记录每一个字母的有效左边界，用 r [N] 数组记录每一个字母的有效右边界，用 last [26] 数组记录上一次该字母出现的位置。<br>对于左边界，我们从左往右遍历，对于有边界，我们从右往左遍历。 </p></blockquote><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">uniqueLetterString</span><span class="params">(string s)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> N=s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> l[N],r[N],last1[<span class="number">26</span>],last2[<span class="number">26</span>]; </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++) last1[i]=<span class="number">-1</span>,last2[i]=N;</span><br><span class="line">        <span class="comment">//last1 记录左边界，last2 记录右边界        </span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//从左到右遍历，l 记录左边界，last1 记录单词出现的位置，用于下一次记录左边界</span></span><br><span class="line">            l[i]=last1[s[i]-<span class="string">&#x27;A&#x27;</span>]; </span><br><span class="line">            last1[s[i]-<span class="string">&#x27;A&#x27;</span>]=i;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//从右到左遍历，同上</span></span><br><span class="line">            r[N-i<span class="number">-1</span>]=last2[s[N-i<span class="number">-1</span>]-<span class="string">&#x27;A&#x27;</span>];</span><br><span class="line">            last2[s[N-i<span class="number">-1</span>]-<span class="string">&#x27;A&#x27;</span>]=N-i<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++) ans+=(i-l[i])*(r[i]-i); <span class="comment">//所有字母的贡献之和就是答案</span></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;div class=&quot;tag link&quot;&gt;&lt;a class=&quot;link-card&quot; title=&quot;力扣 828. 统计子串中的唯一字符&quot; href=&quot;https://leetcode.cn/problems/count-unique-characters-of-all-subs</summary>
      
    
    
    
    <category term="每日一题--队列队" scheme="https://hdheid.github.io/categories/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-%E9%98%9F%E5%88%97%E9%98%9F/"/>
    
    
    <category term="双指针" scheme="https://hdheid.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>2022-09-05未来可期小组每日一题</title>
    <link href="https://hdheid.github.io/posts/b78b9392.html"/>
    <id>https://hdheid.github.io/posts/b78b9392.html</id>
    <published>2022-09-06T08:23:43.882Z</published>
    <updated>2022-09-06T08:53:43.992Z</updated>
    
    <content type="html"><![CDATA[<div class="tag link"><a class="link-card" title="acwing 1470. 水桶传递队列" href="https://www.acwing.com/problem/content/1472/"><div class="left"><img src="https://img.hipyt.cn/imgs/2022/09/e3f773cfe32f6f4f.jpg"/></div><div class="right"><p class="text">acwing 1470. 水桶传递队列</p><p class="url">https://www.acwing.com/problem/content/1472/</p></div></a></div><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>给出一个 10 X 10 的字符串矩阵，’.’，’L’，’B’，’R’，分别表示可以走的点，湖，烧着的牛棚，障碍物。障碍物的点不能经过，答案输出一个 L 到 B 的最短路径。</p><h2 id="题意解析"><a href="#题意解析" class="headerlink" title="题意解析"></a>题意解析</h2><p>一眼看到这个题目的时候，第一时间想起了 BFS，对于走迷宫一类的问题很好解决。对于这个题目，我们以 L 的坐标为为起点，当碰到 B 的时候，就是答案。<br><div class="tip warning faa-parent animated-hover"><p class="faa-horizontal">如果忘记了点击<a href="https://www.acwing.com/video/276/">这里</a>。</p></div></p><h2 id="代码-c"><a href="#代码-c" class="headerlink" title="代码(c++)"></a>代码(c++)</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;PII;</span><br><span class="line"><span class="type">char</span> g[<span class="number">15</span>][<span class="number">15</span>];</span><br><span class="line"><span class="type">int</span> ans[<span class="number">15</span>][<span class="number">15</span>];</span><br><span class="line"><span class="type">bool</span> st[<span class="number">15</span>][<span class="number">15</span>]; <span class="comment">//判断是否走过</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> dx[]=&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>&#125;,dy[]=&#123;<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span>。<span class="comment">//a，b 表示起点(L)坐标</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    queue&lt;PII&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(&#123;a,b&#125;);</span><br><span class="line">    st[a][b]=<span class="number">1</span>;  <span class="comment">//标记走过</span></span><br><span class="line">    <span class="keyword">while</span>(q.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x=q.<span class="built_in">front</span>().first,y=q.<span class="built_in">front</span>().second;</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> xx=x+dx[i],yy=y+dy[i];</span><br><span class="line">            <span class="keyword">if</span>(xx&lt;<span class="number">0</span>||yy&lt;<span class="number">0</span>||xx&gt;<span class="number">9</span>||yy&gt;<span class="number">9</span>||st[xx][yy]||g[xx][yy]==<span class="string">&#x27;R&#x27;</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(g[xx][yy]==<span class="string">&#x27;B&#x27;</span>)</span><br><span class="line">            &#123;<span class="comment">//如果当前点的上下左右某一个点是&#x27;B&#x27;，就证明已经走完了，那么我们直接返回答案</span></span><br><span class="line">                cout&lt;&lt;ans[x][y];</span><br><span class="line">                <span class="keyword">return</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">            ans[xx][yy]=ans[x][y]+<span class="number">1</span>;</span><br><span class="line">            st[xx][yy]=<span class="number">1</span>;</span><br><span class="line">            q.<span class="built_in">push</span>(&#123;xx,yy&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> x,y;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">10</span>;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            cin&gt;&gt;g[i][j];</span><br><span class="line">            <span class="keyword">if</span>(g[i][j]==<span class="string">&#x27;L&#x27;</span>) x=i,y=j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">bfs</span>(x,y);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;div class=&quot;tag link&quot;&gt;&lt;a class=&quot;link-card&quot; title=&quot;acwing 1470. 水桶传递队列&quot; href=&quot;https://www.acwing.com/problem/content/1472/&quot;&gt;&lt;div class=&quot;left&quot;</summary>
      
    
    
    
    <category term="每日一题--未来可期小组" scheme="https://hdheid.github.io/categories/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-%E6%9C%AA%E6%9D%A5%E5%8F%AF%E6%9C%9F%E5%B0%8F%E7%BB%84/"/>
    
    
    <category term="BFS" scheme="https://hdheid.github.io/tags/BFS/"/>
    
  </entry>
  
  <entry>
    <title>2022-09-05队列队每日一题</title>
    <link href="https://hdheid.github.io/posts/1db78182.html"/>
    <id>https://hdheid.github.io/posts/1db78182.html</id>
    <published>2022-09-05T03:39:29.554Z</published>
    <updated>2022-09-05T03:44:47.899Z</updated>
    
    <content type="html"><![CDATA[<div class="tag link"><a class="link-card" title="力扣 6168. 恰好移动 k 步到达某一位置的方法数目" href="https://leetcode.cn/problems/number-of-ways-to-reach-a-position-after-exactly-k-steps/"><div class="left"><img src="https://img.hipyt.cn/imgs/2022/09/e3f773cfe32f6f4f.jpg"/></div><div class="right"><p class="text">力扣 6168. 恰好移动 k 步到达某一位置的方法数目</p><p class="url">https://leetcode.cn/problems/number-of-ways-to-reach-a-position-after-exactly-k-steps/</p></div></a></div><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>给一个起点 s 和终点 e，要求你走 k 步正好从 s到达 e，每一次可以可以向左或者向右走(<strong>走过终点再往回走也行</strong>)，求方案数 MOD 1e9+7 的结果。<br><div class="tip warning faa-parent animated-hover"><p class="faa-horizontal">注意数轴可能有负数</p></div></p><h2 id="题意解析"><a href="#题意解析" class="headerlink" title="题意解析"></a>题意解析</h2><p>使用动态规划：</p><blockquote><ol><li><span class='p red'>dp[i][j]表示走了 i 步，当前位置在 j 的时候的方案数</span></li><li><span class='p red'>初始值 dp[0][s]=1</span></li><li><span class='p red'>状态转移方程：f[i][j] = f[i-1][j-1] + f[i-1][j+1]</span>，表示上一步从左到右和从右到左到达当前位置的方案数总和</li></ol></blockquote><div class="tip warning faa-parent animated-hover"><p class="faa-horizontal">考虑到负数，我们给起点和终点加一个偏移量</p></div><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numberOfWays</span><span class="params">(<span class="type">int</span> s, <span class="type">int</span> e, <span class="type">int</span> k)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> dp[<span class="number">1010</span>][<span class="number">2010</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> MOD=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line">        s+=<span class="number">500</span>; e+=<span class="number">500</span>; <span class="comment">//偏移量</span></span><br><span class="line">        dp[<span class="number">0</span>][s]=<span class="number">1</span>; <span class="comment">//初始化</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=k;i++) <span class="comment">//一共只能走 k 步</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;<span class="number">2005</span>;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                dp[i][j]+=dp[i<span class="number">-1</span>][j<span class="number">-1</span>]; <span class="comment">//从右走到达当前位置</span></span><br><span class="line">                dp[i][j]=(dp[i][j]+dp[i<span class="number">-1</span>][j+<span class="number">1</span>])%MOD; <span class="comment">//从左走到达当前位置</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[k][e];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;div class=&quot;tag link&quot;&gt;&lt;a class=&quot;link-card&quot; title=&quot;力扣 6168. 恰好移动 k 步到达某一位置的方法数目&quot; href=&quot;https://leetcode.cn/problems/number-of-ways-to-reach-a</summary>
      
    
    
    
    <category term="每日一题--队列队" scheme="https://hdheid.github.io/categories/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-%E9%98%9F%E5%88%97%E9%98%9F/"/>
    
    
    <category term="动态规划" scheme="https://hdheid.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>力扣第86场双周赛---第三题</title>
    <link href="https://hdheid.github.io/posts/73d80173.html"/>
    <id>https://hdheid.github.io/posts/73d80173.html</id>
    <published>2022-09-04T07:48:24.204Z</published>
    <updated>2022-09-04T07:53:46.629Z</updated>
    
    <content type="html"><![CDATA[<div class="tag link"><a class="link-card" title="力扣 6173. 被列覆盖的最多行数" href="https://leetcode.cn/problems/maximum-rows-covered-by-columns/"><div class="left"><img src="https://img.hipyt.cn/imgs/2022/09/e3f773cfe32f6f4f.jpg"/></div><div class="right"><p class="text">力扣 6173. 被列覆盖的最多行数</p><p class="url">https://leetcode.cn/problems/maximum-rows-covered-by-columns/</p></div></a></div><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>给出一个 n 行 m 列的二维二进制矩阵(只有 0 和 1 两个数)，再给出一个数 cols 表示你<strong>一共要选出 cols 列</strong>。对于每一行，如果<span class='p red'>这一行中的所有 1 都在你选中的列中</span>，那么称此行被覆盖。问：最多能有多少行被覆盖。</p><h2 id="题意解析"><a href="#题意解析" class="headerlink" title="题意解析"></a>题意解析</h2><div class="tip key"><p>二进制枚举</p></div><p>题目数据很小，矩阵最多 12 X 12 ，因此我们可以使用二进制枚举来完成此题。</p><blockquote><p>对于某一个矩阵列数为 m ，如果我们可以选择任意列数，那么通过高中学习的排列组合知识，我们可以得到 C<sub>m</sub><sup style="margin-left:-10px">1</sup> 一直加到 C<sub>m</sub><sup style="margin-left:-10px">m</sup> 种选择，也就是 2<sup>m</sup> 种选择，也正好对应了 0 到 2<sup>m</sup> 的二进制表示(<strong>0 表示不选择，1 表示选择</strong>)。</p><p> 我们再通过处理过滤掉二进制表示中 1 的个数不等于 cols 的情况，然后再带入矩阵中，找到哪一种选择的覆盖层数最大即可。</p></blockquote><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lowbit</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;<span class="comment">//计算某个数的二进制表示中 1 的个数</span></span><br><span class="line">        <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(x)</span><br><span class="line">        &#123;</span><br><span class="line">            ans++;</span><br><span class="line">            x-=x&amp;-x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maximumRows</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; mat, <span class="type">int</span> cols)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> n=mat.<span class="built_in">size</span>(),m=mat[<span class="number">0</span>].<span class="built_in">size</span>(); <span class="comment">//n行，m列</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// cout&lt;&lt;n&lt;&lt;&#x27; &#x27;&lt;&lt;m&lt;&lt;endl;</span></span><br><span class="line">        <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">1</span>&lt;&lt;m;i++)</span><br><span class="line">        &#123;<span class="comment">//枚举所有选择</span></span><br><span class="line">            <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">lowbit</span>(i)!=cols) <span class="keyword">continue</span>;<span class="comment">//过滤掉不符合情况的选择</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">            &#123;<span class="comment">//对于某一种情况，遍历矩阵判断覆盖层数</span></span><br><span class="line">                <span class="type">bool</span> flag=<span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;m;k++)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">//对于某一层，如果有一列是 1，但是我们这一列没有选择，那么我们这一层就没有被覆盖</span></span><br><span class="line">                    <span class="keyword">if</span>(mat[j][k]&amp;&amp;(i&gt;&gt;k&amp;<span class="number">1</span>)==<span class="number">0</span>) flag=<span class="literal">false</span>;</span><br><span class="line">                    <span class="comment">// cout&lt;&lt;mat[j][k]&lt;&lt;&#x27; &#x27;&lt;&lt;(i&gt;&gt;k&amp;1)&lt;&lt;&#x27; &#x27;&lt;&lt;flag&lt;&lt;endl;</span></span><br><span class="line">                &#125;</span><br><span class="line">                res+=flag;</span><br><span class="line">                <span class="comment">// cout&lt;&lt;endl;</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// cout&lt;&lt;res&lt;&lt;&#x27; &#x27;;</span></span><br><span class="line">            ans=<span class="built_in">max</span>(ans,res);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;div class=&quot;tag link&quot;&gt;&lt;a class=&quot;link-card&quot; title=&quot;力扣 6173. 被列覆盖的最多行数&quot; href=&quot;https://leetcode.cn/problems/maximum-rows-covered-by-columns/&quot;&gt;&lt;</summary>
      
    
    
    
    <category term="力扣周赛" scheme="https://hdheid.github.io/categories/%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B/"/>
    
    
    <category term="二进制枚举" scheme="https://hdheid.github.io/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%9E%9A%E4%B8%BE/"/>
    
  </entry>
  
  <entry>
    <title>力扣第86场双周赛---第二题</title>
    <link href="https://hdheid.github.io/posts/3ec6a221.html"/>
    <id>https://hdheid.github.io/posts/3ec6a221.html</id>
    <published>2022-09-04T07:48:14.648Z</published>
    <updated>2022-09-04T07:55:19.229Z</updated>
    
    <content type="html"><![CDATA[<div class="tag link"><a class="link-card" title="力扣 6172. 严格回文的数字" href="https://leetcode.cn/problems/strictly-palindromic-number/"><div class="left"><img src="https://img.hipyt.cn/imgs/2022/09/e3f773cfe32f6f4f.jpg"/></div><div class="right"><p class="text">力扣 6172. 严格回文的数字</p><p class="url">https://leetcode.cn/problems/strictly-palindromic-number/</p></div></a></div><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>将一个数 n 转化为 b 进制(b 为 2 到 n-2 的整数)，如果在 b 进制下 n 都是回文字符串，那么 n 是严格回文的。是则返回 true；否则返回 false。</p><h2 id="题意解析"><a href="#题意解析" class="headerlink" title="题意解析"></a>题意解析</h2><p>直接将 n 的每一个 b 进制表示出来，在一个个判断是否回文，可以枚举。<br><div class="tip info"><p>知识点：进制转换</p></div></p><blockquote><p>这个题目涉及到的就是进制转换，如何将十进制的 n 转换为其他进制？<br>我们需要用除 b 取余法。简单来说，我们将 n%b，将余数保存在数组，再将 n/b。不断地从重复上述操作，最后保存的数组就是将十进制转化的 b 进制数。<br>需要注意的是：<strong>保存的进制数是从左到右看的，而正常的进制数都是从右到左</strong>。</p></blockquote><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">zh</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">while</span>(n)</span><br><span class="line">        &#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(n%b);</span><br><span class="line">            n/=b;</span><br><span class="line">        &#125;<span class="comment">//将 n 转换为 b 进制数，除 b 取余法</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;ans.<span class="built_in">size</span>()/<span class="number">2</span>;i++)</span><br><span class="line">        &#123;<span class="comment">//因为判断回文，正反看都是一样的，所以这里进制数不需要处理</span></span><br><span class="line">            <span class="keyword">if</span>(ans[i]!=ans[ans.<span class="built_in">size</span>()-i<span class="number">-1</span>]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isStrictlyPalindromic</span><span class="params">(<span class="type">int</span> n)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n<span class="number">-2</span>;i++)</span><br><span class="line">        &#123;<span class="comment">//遍历判断回文即可</span></span><br><span class="line">            <span class="keyword">if</span>(!<span class="built_in">zh</span>(n,i)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;div class=&quot;tag link&quot;&gt;&lt;a class=&quot;link-card&quot; title=&quot;力扣 6172. 严格回文的数字&quot; href=&quot;https://leetcode.cn/problems/strictly-palindromic-number/&quot;&gt;&lt;div cl</summary>
      
    
    
    
    <category term="力扣周赛" scheme="https://hdheid.github.io/categories/%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B/"/>
    
    
    <category term="进制转换" scheme="https://hdheid.github.io/tags/%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2/"/>
    
  </entry>
  
  <entry>
    <title>力扣第86场双周---第一题</title>
    <link href="https://hdheid.github.io/posts/64bab674.html"/>
    <id>https://hdheid.github.io/posts/64bab674.html</id>
    <published>2022-09-04T07:48:04.845Z</published>
    <updated>2022-09-04T07:51:26.109Z</updated>
    
    <content type="html"><![CDATA[<div class="tag link"><a class="link-card" title="力扣 6171. 和相等的子数组" href="https://leetcode.cn/problems/find-subarrays-with-equal-sum/"><div class="left"><img src="https://img.hipyt.cn/imgs/2022/09/e3f773cfe32f6f4f.jpg"/></div><div class="right"><p class="text">力扣 6171. 和相等的子数组</p><p class="url">https://leetcode.cn/problems/find-subarrays-with-equal-sum/</p></div></a></div><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>判断在一个数组 nums 中，是否存在两个长度为 2 的子数组且它们的和相等，存在则返回 true，否则返回 false。</p><h2 id="题意解析"><a href="#题意解析" class="headerlink" title="题意解析"></a>题意解析</h2><p>我们直接使用哈希表，遍历每个长度为 2 的子数组，其和对应的键值加一，直到存在某个键值大于一。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">findSubarrays</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">bool</span> flag=<span class="literal">false</span>;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; mp; <span class="comment">//哈希表</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>()<span class="number">-1</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            mp[nums[i]+nums[i+<span class="number">1</span>]]++;</span><br><span class="line">            <span class="keyword">if</span>(mp[nums[i]+nums[i+<span class="number">1</span>]]&gt;<span class="number">1</span>) <span class="comment">//存在至少两个</span></span><br><span class="line">            &#123;</span><br><span class="line">                flag=<span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> flag;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;div class=&quot;tag link&quot;&gt;&lt;a class=&quot;link-card&quot; title=&quot;力扣 6171. 和相等的子数组&quot; href=&quot;https://leetcode.cn/problems/find-subarrays-with-equal-sum/&quot;&gt;&lt;div </summary>
      
    
    
    
    <category term="力扣周赛" scheme="https://hdheid.github.io/categories/%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B/"/>
    
    
    <category term="哈希表" scheme="https://hdheid.github.io/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>2022-09-03未来可期小组每日一题</title>
    <link href="https://hdheid.github.io/posts/91dbe174.html"/>
    <id>https://hdheid.github.io/posts/91dbe174.html</id>
    <published>2022-09-03T12:31:52.334Z</published>
    <updated>2022-09-03T15:26:41.627Z</updated>
    
    <content type="html"><![CDATA[<div class="tag link"><a class="link-card" title="acwing 1681. 谷仓刷漆" href="https://www.acwing.com/problem/content/1683/"><div class="left"><img src="https://img.hipyt.cn/imgs/2022/09/e3f773cfe32f6f4f.jpg"/></div><div class="right"><p class="text">acwing 1681. 谷仓刷漆</p><p class="url">https://www.acwing.com/problem/content/1683/</p></div></a></div><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>约翰给一个二维平面刷油漆，一共刷 n 次，每次刷的面积是一个矩形，会给出左下角和右上角的点的坐标来表示。在给出一个数 k，问 n 次刷漆过后被刷过 k 次漆的面积有多大。</p><h2 id="题意解析"><a href="#题意解析" class="headerlink" title="题意解析"></a>题意解析</h2><p>这个题目很明显要用到二维差分和二维前缀和的知识，我们将每一次刷过的矩形中的每个数加一，最后遍历整个二维平面，计算有多少个数等于 k 就行。<br><div class="tip key"><p>细节方面</p></div></p><blockquote><ol><li>由于题目给的是坐标轴上的坐标，就”相当于”二维数组的左上角和右下角，所以不用变换坐标</li><li>由于给的是点的坐标，我们需要的是格子的坐标，所以需要将给出的左下角的坐标加一</li><li><a href="https://www.acwing.com/solution/content/27325/">差分矩阵</a></li></ol></blockquote><h2 id="代码-c"><a href="#代码-c" class="headerlink" title="代码(c++)"></a>代码(c++)</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1010</span>;</span><br><span class="line"><span class="type">int</span> a[N][N],b[N][N];</span><br><span class="line"><span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> x1,<span class="type">int</span> y1,<span class="type">int</span> x2,<span class="type">int</span> y2,<span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    b[x1][y1]+=c;</span><br><span class="line">    b[x1][y2+<span class="number">1</span>]-=c;</span><br><span class="line">    b[x2+<span class="number">1</span>][y1]-=c;</span><br><span class="line">    b[x2+<span class="number">1</span>][y2+<span class="number">1</span>]+=c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,k;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> max_x=<span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> x1,y1,x2,y2;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;x1&gt;&gt;y1&gt;&gt;x2&gt;&gt;y2;</span><br><span class="line">        <span class="built_in">insert</span>(x1+<span class="number">1</span>,y1+<span class="number">1</span>,x2,y2,<span class="number">1</span>);  <span class="comment">//因为给的点是坐标，我们用差分计算面积(格子数量)，所以需要加一</span></span><br><span class="line">        max_x=<span class="built_in">max</span>(max_x,<span class="built_in">max</span>(<span class="built_in">max</span>(x1+<span class="number">1</span>,x2+<span class="number">1</span>),<span class="built_in">max</span>(y1+<span class="number">1</span>,y2+<span class="number">1</span>)));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=max_x;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=max_x;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            b[i][j]+=b[i][j<span class="number">-1</span>]+b[i<span class="number">-1</span>][j]-b[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">            <span class="keyword">if</span>(b[i][j]==k) ans++;</span><br><span class="line">            <span class="comment">// cout&lt;&lt;b[i][j]&lt;&lt;&#x27; &#x27;;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// cout&lt;&lt;endl;</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;div class=&quot;tag link&quot;&gt;&lt;a class=&quot;link-card&quot; title=&quot;acwing 1681. 谷仓刷漆&quot; href=&quot;https://www.acwing.com/problem/content/1683/&quot;&gt;&lt;div class=&quot;left&quot;&gt;&lt;</summary>
      
    
    
    
    <category term="每日一题--未来可期小组" scheme="https://hdheid.github.io/categories/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-%E6%9C%AA%E6%9D%A5%E5%8F%AF%E6%9C%9F%E5%B0%8F%E7%BB%84/"/>
    
    
    <category term="二维前缀和" scheme="https://hdheid.github.io/tags/%E4%BA%8C%E7%BB%B4%E5%89%8D%E7%BC%80%E5%92%8C/"/>
    
    <category term="二维差分" scheme="https://hdheid.github.io/tags/%E4%BA%8C%E7%BB%B4%E5%B7%AE%E5%88%86/"/>
    
  </entry>
  
  <entry>
    <title>2022-09-03队列队每日一题</title>
    <link href="https://hdheid.github.io/posts/6f46db02.html"/>
    <id>https://hdheid.github.io/posts/6f46db02.html</id>
    <published>2022-09-03T08:32:43.384Z</published>
    <updated>2022-09-03T12:33:26.187Z</updated>
    
    <content type="html"><![CDATA[<div class="tag link"><a class="link-card" title="力扣 646. 最长数对链" href="https://leetcode.cn/classic/problems/maximum-length-of-pair-chain/description/"><div class="left"><img src="https://img.hipyt.cn/imgs/2022/09/e3f773cfe32f6f4f.jpg"/></div><div class="right"><p class="text">力扣 646. 最长数对链</p><p class="url">https://leetcode.cn/classic/problems/maximum-length-of-pair-chain/description/</p></div></a></div><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>给出 n 个数对，设 [a,b] , [c,d] (<strong>a&lt;b，c&lt;d</strong>)为一对数对，<span class='p red'>当且仅当 b < c 的时候，这两个数对可以形成数对链</span>，数对可以以任意顺序排列，<strong>求出最长的序列对(不必使用所有的数对)</strong>。(1&lt;=n&lt;=1000)</p><h2 id="题意解析"><a href="#题意解析" class="headerlink" title="题意解析"></a>题意解析</h2><p>首先附上<a href="https://leetcode.cn/problems/maximum-length-of-pair-chain/solution/zui-chang-shu-dui-lian-by-leetcode-solut-ifpn/">官方题解</a></p><p>这个题目与力扣的<a href="https://leetcode.cn/problems/longest-increasing-subsequence/">300. 最长递增子序列</a>的题目所使用的方法类似，可以使用动态规划<sup><a href="#fn_1" id="reffn_1">1</a></sup>的方法解决。<br><div class="tip info"><p>图片写法参考自<a href="https://www.acwing.com/video/327/">https://www.acwing.com/video/327/</a> </p></div><br><div class="img-wrap"><div class="img-bg"><img class="img" src="https://img.hipyt.cn/imgs/2022/09/01f559874e4e9f0e.jpg"/></div></div></p><p>对于当前第 i 个数对，如果可以和之前的某一个数对 j 形成数对链，那么 dp[i] 就可以更新为 dp[i] 和 dp[j]+1 的较大值。(<strong>dp[j]+1 表示前面的数对链加上当前数对的个数</strong>)<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if(p[i][0]&gt;p[j][1])</span><br><span class="line">&#123;</span><br><span class="line">    dp[i]=max(dp[i],dp[j]+1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findLongestChain</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; p)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(p.<span class="built_in">begin</span>(),p.<span class="built_in">end</span>()); <span class="comment">//考虑到题目说的任意顺序，这里一定要排序</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(p.size())</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;p.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i]=<span class="number">1</span>; <span class="comment">//其本身也算一个</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=i;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(p[i][<span class="number">0</span>]&gt;p[j][<span class="number">1</span>])</span><br><span class="line">                &#123;<span class="comment">//如果当前数对可以加在前面的数对链后面</span></span><br><span class="line">                    dp[i]=<span class="built_in">max</span>(dp[i],dp[j]+<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> ans=<span class="number">0</span>;<span class="comment">//求出最大值</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> x : dp) ans=<span class="built_in">max</span>(ans,x);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote id="fn_1"><sup>1</sup>. 通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法。<a href="#reffn_1" title="Jump back to footnote [1] in the text."> &#8617;</a></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;div class=&quot;tag link&quot;&gt;&lt;a class=&quot;link-card&quot; title=&quot;力扣 646. 最长数对链&quot; href=&quot;https://leetcode.cn/classic/problems/maximum-length-of-pair-chain/des</summary>
      
    
    
    
    <category term="每日一题--队列队" scheme="https://hdheid.github.io/categories/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-%E9%98%9F%E5%88%97%E9%98%9F/"/>
    
    
    <category term="动态规划" scheme="https://hdheid.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    <category term="线性dp" scheme="https://hdheid.github.io/tags/%E7%BA%BF%E6%80%A7dp/"/>
    
    <category term="最长上升子序列" scheme="https://hdheid.github.io/tags/%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>2022-09-02未来可期小组每日一题</title>
    <link href="https://hdheid.github.io/posts/9f3c09a5.html"/>
    <id>https://hdheid.github.io/posts/9f3c09a5.html</id>
    <published>2022-09-02T12:41:19.316Z</published>
    <updated>2022-09-02T12:50:44.105Z</updated>
    
    <content type="html"><![CDATA[<div class="tag link"><a class="link-card" title="acwing 1680. 困牛放牧" href="https://www.acwing.com/problem/content/1682/"><div class="left"><img src="https://img.hipyt.cn/imgs/2022/09/e3f773cfe32f6f4f.jpg"/></div><div class="right"><p class="text">acwing 1680. 困牛放牧</p><p class="url">https://www.acwing.com/problem/content/1682/</p></div></a></div><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>有 n 头牛，随机分布在一条坐标轴上，每一次可以令一头最左或最右(左右端点)的牛移动到<strong>任意两头牛中间(不能移动到端点)</strong>，最终让所有的牛在坐标轴上连续，输出移动的最大次数和最小次数。</p><h2 id="题意解析"><a href="#题意解析" class="headerlink" title="题意解析"></a>题意解析</h2><p><strong>首先先对这堆数据进行排序，然后我们分别求出最大值和最小值</strong></p><div class="tabs" id=""><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#-1">最大值</button></li><li class="tab"><button type="button" data-href="#-2">最小值</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="-1"><p>对于最大值，显然我们一个一个的移动，移动次数是最大的。但是第一步一定是移动左右两个端点，所以我们一定会失去<b>第一个点到第二个点之间的距离</b>或者<b>倒数一个点到倒数二个点之间的距离</b>，因此我们计算<b>第二个点到最后一个点的距离和第一个点到倒数第二个点的距离谁大就行</b></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="-2"><p>对于最小值，我们不管怎么移动，到最后一定会是一个长度为 n 的序列，因此，我们可以选择遍历每一段 n 长度的线段，找出奶牛最多的那一段，也就是需要移动的次数最少的那一段。</p><div class="tip warning faa-parent animated-hover"><p class="faa-horizontal">需要注意的是，如果除了第一个点或者最后一个点，其他点全部都相邻，那么只需要两步就可以解决</p></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="代码-c"><a href="#代码-c" class="headerlink" title="代码(c++)"></a>代码(c++)</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> ans_min,ans_max;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) cin&gt;&gt;a[i];</span><br><span class="line">    <span class="built_in">sort</span>(a,a+n);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//最小值</span></span><br><span class="line">    <span class="comment">//如果等于二，可以将另外一边的端点移动到空里，只需一步</span></span><br><span class="line">    <span class="comment">//例如:3，4，5，6，8 ，直接将 3 移动到 7 的位置</span></span><br><span class="line">    <span class="keyword">if</span>((a[n<span class="number">-1</span>]-a[n<span class="number">-2</span>]&gt;<span class="number">2</span>&amp;&amp;a[n<span class="number">-2</span>]-a[<span class="number">0</span>]==n<span class="number">-2</span>)||(a[<span class="number">1</span>]-a[<span class="number">0</span>]&gt;<span class="number">2</span>&amp;&amp;a[n<span class="number">-1</span>]-a[<span class="number">1</span>]==n<span class="number">-2</span>)) ans_min=<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> cow_max=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//利用双指针求出在每一段 n 内有多少头牛</span></span><br><span class="line">            <span class="keyword">while</span>(j&lt;n<span class="number">-1</span>&amp;&amp;a[j+<span class="number">1</span>]-a[i]&lt;=n<span class="number">-1</span>) j++;</span><br><span class="line">            cow_max=<span class="built_in">max</span>(cow_max,j-i+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        ans_min=n-cow_max;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 最大值</span></span><br><span class="line">    ans_max=<span class="built_in">max</span>(a[n<span class="number">-2</span>]-a[<span class="number">0</span>],a[n<span class="number">-1</span>]-a[<span class="number">1</span>])-n+<span class="number">2</span>;</span><br><span class="line">    </span><br><span class="line">    cout&lt;&lt;ans_min&lt;&lt;endl&lt;&lt;ans_max&lt;&lt;endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;div class=&quot;tag link&quot;&gt;&lt;a class=&quot;link-card&quot; title=&quot;acwing 1680. 困牛放牧&quot; href=&quot;https://www.acwing.com/problem/content/1682/&quot;&gt;&lt;div class=&quot;left&quot;&gt;&lt;</summary>
      
    
    
    
    <category term="每日一题--未来可期小组" scheme="https://hdheid.github.io/categories/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-%E6%9C%AA%E6%9D%A5%E5%8F%AF%E6%9C%9F%E5%B0%8F%E7%BB%84/"/>
    
    
    <category term="技巧题" scheme="https://hdheid.github.io/tags/%E6%8A%80%E5%B7%A7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>2022-09-02队列队每日一题</title>
    <link href="https://hdheid.github.io/posts/786ebfc2.html"/>
    <id>https://hdheid.github.io/posts/786ebfc2.html</id>
    <published>2022-09-02T05:45:16.969Z</published>
    <updated>2022-09-03T12:32:47.705Z</updated>
    
    <content type="html"><![CDATA[<div class="tag link"><a class="link-card" title="力扣1545. 找出第 N 个二进制字符串中的第 K 位" href="https://leetcode.cn/problems/find-kth-bit-in-nth-binary-string/"><div class="left"><img src="https://img.hipyt.cn/imgs/2022/09/e3f773cfe32f6f4f.jpg"/></div><div class="right"><p class="text">力扣1545. 找出第 N 个二进制字符串中的第 K 位</p><p class="url">https://leetcode.cn/problems/find-kth-bit-in-nth-binary-string/</p></div></a></div><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>给你一个 n 和 k 数，输出 S~n~的第 k 的字母；</p><blockquote><ol><li>S<sub>1</sub> = “0”；</li><li>对于 S<sub>i</sub> (<strong>i&gt;1</strong>)，S<sub>i</sub> = S<sub>i-1</sub> + “1” + 反转和颠倒的 S<sub>i-1</sub>；</li></ol></blockquote><div class="tip warning faa-parent animated-hover"><p class="faa-horizontal">反转指将每一位的 "0"变"1"，"1"变"0"；颠倒指将字符串反过来</p></div><h2 id="题意解析"><a href="#题意解析" class="headerlink" title="题意解析"></a>题意解析</h2><p>这个题目因为 n 只有 20，所以如果用暴力的方法也可以做出来，另一种方法是递归，接下来详细讲述递归的方法。</p><blockquote><ol><li>对于一个 n，我们通过数学归纳可以得到<strong> S<sub>n</sub> 的长度为 2<sup>n</sup>-1</strong>。</li><li>由题目可以知道，如果 k 正好等于 2<sup>n-1</sup>，也就是正中间那个 1，那么可以直接返回 1；</li><li>其次，当 k &lt; 2<sup>n-1</sup>，那么 k 就在 S<sub>n-1</sub> 里面找，也就是 S<sub>n</sub> 的前半段</li><li>最后，当 k &gt; 2<sup>n-1</sup>，那么 k 就在 S<sub>n</sub> 的后半段里面找。此处，第 k 个字符也就是从右往左的第 2<sup>n</sup>-k 个字符，然后反转一下</li></ol></blockquote><h2 id="代码-c-暴力版"><a href="#代码-c-暴力版" class="headerlink" title="代码(c++) 暴力版"></a>代码(c++) 暴力版</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">char</span> <span class="title">findKthBit</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>) <span class="keyword">return</span> <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        string s1;</span><br><span class="line">        s1=<span class="string">&quot;0&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            string str=s1;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;x : str) x^=<span class="number">1</span>;   <span class="comment">//用 str 存储反转后的 s1</span></span><br><span class="line">            <span class="built_in">reverse</span>(str.<span class="built_in">begin</span>(),str.<span class="built_in">end</span>());  <span class="comment">//颠倒</span></span><br><span class="line">            s1+=<span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">            s1+=str;   <span class="comment">//相加</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s1[k<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="代码-c-递归版"><a href="#代码-c-递归版" class="headerlink" title="代码(c++) 递归版"></a>代码(c++) 递归版</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">char</span> <span class="title">findKthBit</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(k==<span class="number">1</span>) <span class="keyword">return</span> <span class="string">&#x27;0&#x27;</span>; <span class="comment">//当 k 等于 1 的时候，一定是 0</span></span><br><span class="line">        <span class="type">int</span> z=<span class="number">1</span>&lt;&lt;(n<span class="number">-1</span>);    <span class="comment">//记录 Sn 中间那个一的位置</span></span><br><span class="line">        <span class="keyword">if</span>(k==z) <span class="keyword">return</span> <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(k&gt;z) <span class="keyword">return</span> <span class="built_in">findKthBit</span>(n<span class="number">-1</span>,(<span class="number">1</span>&lt;&lt;n)-k)^<span class="number">1</span>; <span class="comment">//如果大于，则从右往左找，^1 将其反转</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">findKthBit</span>(n<span class="number">-1</span>,k);   <span class="comment">//同理，不用反转    </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;div class=&quot;tag link&quot;&gt;&lt;a class=&quot;link-card&quot; title=&quot;力扣1545. 找出第 N 个二进制字符串中的第 K 位&quot; href=&quot;https://leetcode.cn/problems/find-kth-bit-in-nth-binar</summary>
      
    
    
    
    <category term="每日一题--队列队" scheme="https://hdheid.github.io/categories/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-%E9%98%9F%E5%88%97%E9%98%9F/"/>
    
    
    <category term="递归" scheme="https://hdheid.github.io/tags/%E9%80%92%E5%BD%92/"/>
    
    <category term="暴力" scheme="https://hdheid.github.io/tags/%E6%9A%B4%E5%8A%9B/"/>
    
  </entry>
  
  <entry>
    <title>2022-09-01未来可期小组每日一题</title>
    <link href="https://hdheid.github.io/posts/8c1430d6.html"/>
    <id>https://hdheid.github.io/posts/8c1430d6.html</id>
    <published>2022-09-01T06:03:42.862Z</published>
    <updated>2022-09-01T12:28:20.260Z</updated>
    
    <content type="html"><![CDATA[<hr><h2 id=""><a href="#" class="headerlink" title=""></a><div class="tag link"><a class="link-card" title="acwing 1685. 测量测量" href="https://www.acwing.com/problem/content/1687/"><div class="left"><img src="https://img.hipyt.cn/imgs/2022/09/e3f773cfe32f6f4f.jpg"/></div><div class="right"><p class="text">acwing 1685. 测量测量</p><p class="url">https://www.acwing.com/problem/content/1687/</p></div></a></div></h2><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>有一个 n 英里的路，一个人在每一英里的路上放一个探测器记录车流量，这个探测器只能记录大概的范围，如果这一英里的路有匝道出口，则探测器<strong>放在出口</strong>，入口同理；</p><blockquote><ol><li>输入 n</li><li>每行有三个数据，第一个是字符：”none”表示没有出入口；”off”表示有出口；”on”表示有入口</li><li>要求输出这条 n 英里的路之前和之后的车流量范围</li></ol></blockquote><h2 id="题意解析"><a href="#题意解析" class="headerlink" title="题意解析"></a>题意解析</h2><ol><li>首先看 n 英里之后，我们先用 <strong>l，r 表示范围，l[i]，r[i]表示探测的数据</strong>，我们从头遍历每一个数据，如果遇到入口，则我们在 l 和 r 上加上相应的数值，<strong>即范围更新为：[ l+l[i]，r+r[i] ]</strong>；<strong>要注意的是</strong>，如果是出口，则应该让 l 减去 r[i]，因为我们要保证数据更加的精准<strong>即范围更新为：[ l-r[i]，r-l[i] ]</strong>；如果没有出入口，则 l 与 l[i]取最大，r 与 r[i]取最小<strong>即范围更新为：[ max(l,l[i])，min(r,r[i]) ]</strong>。</li><li>然后看 1 英里之前，大致方法同上，区别在于<strong>我们从尾遍历到头</strong></li></ol><h2 id="代码-c"><a href="#代码-c" class="headerlink" title="代码(c++)"></a>代码(c++)</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> l[<span class="number">110</span>],r[<span class="number">110</span>];</span><br><span class="line">string s[<span class="number">110</span>];</span><br><span class="line"><span class="type">int</span> n; </span><br><span class="line"><span class="type">int</span> l_s=<span class="number">0</span>,r_s=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">int</span> l_e=<span class="number">0</span>,r_e=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) cin&gt;&gt;s[i]&gt;&gt;l[i]&gt;&gt;r[i];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)  <span class="comment">//从尾到头</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i]==<span class="string">&quot;none&quot;</span>) l_s=<span class="built_in">max</span>(l_s,l[i]),r_s=<span class="built_in">min</span>(r_s,r[i]);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(s[i]==<span class="string">&quot;on&quot;</span>) l_s-=r[i],r_s-=l[i];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(s[i]==<span class="string">&quot;off&quot;</span>) l_s+=l[i],r_s+=r[i];</span><br><span class="line">    &#125;</span><br><span class="line">    l_s=<span class="built_in">max</span>(<span class="number">0</span>,l_s); r_s=<span class="built_in">max</span>(<span class="number">0</span>,r_s); <span class="comment">//要注意有肯能有可能小于零</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)  <span class="comment">//从头到尾</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i]==<span class="string">&quot;none&quot;</span>) l_e=<span class="built_in">max</span>(l_e,l[i]),r_e=<span class="built_in">min</span>(r_e,r[i]);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(s[i]==<span class="string">&quot;on&quot;</span>) l_e+=l[i],r_e+=r[i];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(s[i]==<span class="string">&quot;off&quot;</span>) l_e-=r[i],r_e-=l[i];</span><br><span class="line">    &#125;</span><br><span class="line">    l_e=<span class="built_in">max</span>(<span class="number">0</span>,l_e); r_e=<span class="built_in">max</span>(<span class="number">0</span>,r_e);</span><br><span class="line">    </span><br><span class="line">    cout&lt;&lt;l_s&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;r_s&lt;&lt;endl&lt;&lt;l_e&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;r_e&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;h2 id=&quot;&quot;&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title=&quot;&quot;&gt;&lt;/a&gt;&lt;div class=&quot;tag link&quot;&gt;&lt;a class=&quot;link-card&quot; title=&quot;acwing 1685. 测量测量&quot; href=&quot;https:</summary>
      
    
    
    
    <category term="每日一题--未来可期小组" scheme="https://hdheid.github.io/categories/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-%E6%9C%AA%E6%9D%A5%E5%8F%AF%E6%9C%9F%E5%B0%8F%E7%BB%84/"/>
    
    
    <category term="技巧题" scheme="https://hdheid.github.io/tags/%E6%8A%80%E5%B7%A7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>2022-09-01队列队每日一题</title>
    <link href="https://hdheid.github.io/posts/41161282.html"/>
    <id>https://hdheid.github.io/posts/41161282.html</id>
    <published>2022-09-01T06:03:32.649Z</published>
    <updated>2022-09-03T12:32:30.934Z</updated>
    
    <content type="html"><![CDATA[<hr><h2 id=""><a href="#" class="headerlink" title=""></a><div class="tag link"><a class="link-card" title="力扣 1475. 商品折扣后的最终价格" href="https://leetcode.cn/problems/final-prices-with-a-special-discount-in-a-shop/"><div class="left"><img src="https://img.hipyt.cn/imgs/2022/09/e3f773cfe32f6f4f.jpg"/></div><div class="right"><p class="text">力扣 1475. 商品折扣后的最终价格</p><p class="url">https://leetcode.cn/problems/final-prices-with-a-special-discount-in-a-shop/</p></div></a></div></h2><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>给出一个数组，对于每一个数 prices[i]，找到它右边第一个比它小的数 prices[j]，然后让这个数减去 prices[j]，否则就不变。</p><h2 id="题意解析"><a href="#题意解析" class="headerlink" title="题意解析"></a>题意解析</h2><p>有一种单调栈的做法。<a href="https://blog.csdn.net/lucky52529/article/details/89155694">单调栈</a>是一种数据结构。对于这个题，题目要求是找到这个数右边第一个比它小的数字，我们可以<strong>从右到左</strong>遍历这个数组，让数据<strong>从栈低到栈顶依次递增</strong>。<br>这个时候我们会遇到三种情况:</p><blockquote><ol><li>当前元素比栈顶元素小；我们依次弹出栈顶元素(<strong>此时栈顶元素会越来越小</strong>)，直到遇到第一个比自己小的元素，并记录当前元素减去栈顶元素的值，然后将当前元素入栈</li><li>当前元素比栈顶元素大；我们直接记录当前元素减去栈顶元素的值，然后将当前元素入栈</li><li>当栈为空时，记录当前元素的值，入栈</li></ol></blockquote><h2 id="代码-c"><a href="#代码-c" class="headerlink" title="代码(c++)"></a>代码(c++)</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">finalPrices</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; s;</span><br><span class="line">        <span class="comment">//可以直接倒序遍历，如果反转了数组，答案数组也是反的</span></span><br><span class="line">        <span class="built_in">reverse</span>(prices.<span class="built_in">begin</span>(),prices.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> x : prices)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(s.<span class="built_in">size</span>()&amp;&amp;s.<span class="built_in">top</span>()&gt;x) s.<span class="built_in">pop</span>();</span><br><span class="line">            ans.<span class="built_in">push_back</span>(s.<span class="built_in">size</span>() ? x-s.<span class="built_in">top</span>() : x);</span><br><span class="line">            s.<span class="built_in">push</span>(x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">reverse</span>(ans.<span class="built_in">begin</span>(),ans.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;h2 id=&quot;&quot;&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title=&quot;&quot;&gt;&lt;/a&gt;&lt;div class=&quot;tag link&quot;&gt;&lt;a class=&quot;link-card&quot; title=&quot;力扣 1475. 商品折扣后的最终价格&quot; href=&quot;http</summary>
      
    
    
    
    <category term="每日一题--队列队" scheme="https://hdheid.github.io/categories/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-%E9%98%9F%E5%88%97%E9%98%9F/"/>
    
    
    <category term="算法" scheme="https://hdheid.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="单调栈" scheme="https://hdheid.github.io/tags/%E5%8D%95%E8%B0%83%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>2022-08-31队列队每日一题</title>
    <link href="https://hdheid.github.io/posts/9278bbb1.html"/>
    <id>https://hdheid.github.io/posts/9278bbb1.html</id>
    <published>2022-08-31T13:03:23.003Z</published>
    <updated>2022-09-03T12:32:14.236Z</updated>
    
    <content type="html"><![CDATA[<hr><h2 id=""><a href="#" class="headerlink" title=""></a><div class="tag link"><a class="link-card" title="力扣 946.验证栈序列" href="https://leetcode.cn/problems/validate-stack-sequences/"><div class="left"><img src="https://img.hipyt.cn/imgs/2022/09/e3f773cfe32f6f4f.jpg"/></div><div class="right"><p class="text">力扣 946.验证栈序列</p><p class="url">https://leetcode.cn/problems/validate-stack-sequences/</p></div></a></div></h2><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>我们将<strong>pushed</strong>里面的数压栈，在压栈的同时如果与<strong>popped</strong>里面的数值相同，则出栈，看最后<strong>是否能够全部出出栈</strong></p><h2 id="题意解析"><a href="#题意解析" class="headerlink" title="题意解析"></a>题意解析</h2><p>题目的目的是判断是否能够全部出栈，我们直接<strong>先将poped数组的数字反过来压栈，再将pushed数组的数字一个一个入栈并且将栈顶的数字进行比较，出栈直到两个栈的栈顶不同</strong></p><h2 id="代码-c"><a href="#代码-c" class="headerlink" title="代码(c++)"></a>代码(c++)</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">validateStackSequences</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; pu, vector&lt;<span class="type">int</span>&gt;&amp; po)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; s1,s2; </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=po.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--) s2.<span class="built_in">push</span>(po[i]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;pu.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            s1.<span class="built_in">push</span>(pu[i]);</span><br><span class="line">            <span class="keyword">while</span>(s1.<span class="built_in">size</span>()&amp;&amp;s1.<span class="built_in">top</span>()==s2.<span class="built_in">top</span>()) s1.<span class="built_in">pop</span>(),s2.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> !s2.<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;h2 id=&quot;&quot;&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title=&quot;&quot;&gt;&lt;/a&gt;&lt;div class=&quot;tag link&quot;&gt;&lt;a class=&quot;link-card&quot; title=&quot;力扣 946.验证栈序列&quot; href=&quot;https://lee</summary>
      
    
    
    
    <category term="每日一题--队列队" scheme="https://hdheid.github.io/categories/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-%E9%98%9F%E5%88%97%E9%98%9F/"/>
    
    
    <category term="算法" scheme="https://hdheid.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="栈" scheme="https://hdheid.github.io/tags/%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>2022-08-31未来可期小组每日一题</title>
    <link href="https://hdheid.github.io/posts/e42af308.html"/>
    <id>https://hdheid.github.io/posts/e42af308.html</id>
    <published>2022-08-31T12:10:55.725Z</published>
    <updated>2022-09-01T12:26:25.106Z</updated>
    
    <content type="html"><![CDATA[<hr><h2 id=""><a href="#" class="headerlink" title=""></a><div class="tag link"><a class="link-card" title="acwing 1684. 大型植被恢复" href="https://www.acwing.com/problem/content/1686/"><div class="left"><img src="https://img.hipyt.cn/imgs/2022/09/e3f773cfe32f6f4f.jpg"/></div><div class="right"><p class="text">acwing 1684. 大型植被恢复</p><p class="url">https://www.acwing.com/problem/content/1686/</p></div></a></div></h2><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>有 n 个点和 m 条边，有四种颜色对每个点进行染色，每个点 <strong>最多能连接三条边</strong>，一条边的两个点<strong>不能染成相同的颜色</strong>，请输出<strong>字典序最小</strong>的染色方法</p><h2 id="题意解析"><a href="#题意解析" class="headerlink" title="题意解析"></a>题意解析</h2><p>我们对每个点使用<strong>邻接表建边</strong>，用<strong>st</strong>数组进行标记，然后从遍历每个点，每个点染色后，其对应的另一个点就删去这个颜色，因为有四种颜色，每个点最多三条边，故<strong>一次遍历就能够得出答案</strong></p><h2 id="代码-c"><a href="#代码-c" class="headerlink" title="代码(c++)"></a>代码(c++)</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> h[<span class="number">110</span>],e[<span class="number">310</span>],ne[<span class="number">310</span>],idx;</span><br><span class="line"><span class="type">bool</span> st[<span class="number">110</span>][<span class="number">5</span>];</span><br><span class="line"><span class="type">int</span> ans[<span class="number">110</span>];</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx]=b; ne[idx]=h[a]; h[a]=idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a,b;</span><br><span class="line">        cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">        <span class="built_in">add</span>(a,b),<span class="built_in">add</span>(b,a);<span class="comment">//建边，把牛当成边，草地当成点</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123; <span class="comment">//遍历每一个点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=<span class="number">4</span>;j++)</span><br><span class="line">        &#123;<span class="comment">//从头开始遍历，确保是最小字典序</span></span><br><span class="line">            <span class="keyword">if</span>(!st[i][j])</span><br><span class="line">            &#123;</span><br><span class="line">                ans[i]=j; </span><br><span class="line">                <span class="comment">//如果这种草能够选择，那么与这个点有边的点都不能选这种草</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k=h[i];~k;k=ne[k]) st[e[k]][j]=<span class="number">1</span>;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) cout&lt;&lt;ans[i];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;h2 id=&quot;&quot;&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title=&quot;&quot;&gt;&lt;/a&gt;&lt;div class=&quot;tag link&quot;&gt;&lt;a class=&quot;link-card&quot; title=&quot;acwing 1684. 大型植被恢复&quot; href=&quot;http</summary>
      
    
    
    
    <category term="每日一题--未来可期小组" scheme="https://hdheid.github.io/categories/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-%E6%9C%AA%E6%9D%A5%E5%8F%AF%E6%9C%9F%E5%B0%8F%E7%BB%84/"/>
    
    
    <category term="算法" scheme="https://hdheid.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="邻接表" scheme="https://hdheid.github.io/tags/%E9%82%BB%E6%8E%A5%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://hdheid.github.io/posts/4a17b156.html"/>
    <id>https://hdheid.github.io/posts/4a17b156.html</id>
    <published>2022-08-29T05:31:32.203Z</published>
    <updated>2022-08-29T14:26:18.700Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
</feed>
