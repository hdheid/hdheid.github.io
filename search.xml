<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>2022-09-16队列队每日一题</title>
      <link href="/posts/bfbcc616.html"/>
      <url>/posts/bfbcc616.html</url>
      
        <content type="html"><![CDATA[<div class="tag link"><a class="link-card" title="力扣 1114. 棋盘问题" href="https://www.acwing.com/problem/content/description/1116/"><div class="left"><img src="https://img.hipyt.cn/imgs/2022/09/e3f773cfe32f6f4f.jpg"/></div><div class="right"><p class="text">力扣 1114. 棋盘问题</p><p class="url">https://www.acwing.com/problem/content/description/1116/</p></div></a></div><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>给出一个棋盘，棋盘上为 <strong>‘#’</strong> 的位置才能放棋子，并且<strong>每一行每一列</strong>只能放一个旗子，有多组数据，当输入为 -1-1 的时候结束。</p><h2 id="题意解析"><a href="#题意解析" class="headerlink" title="题意解析"></a>题意解析</h2><p>这个题目与昨天的 n 皇后问题类似，区别在与它只放 k 个棋子，k 可能小于 n，并且只有特定区域才能放棋子。还是使用 DFS 的方法来做。</p><blockquote><p>一行一行的枚举，找到能放棋子的位置，cnt 计数，当放满 k 个棋子后，答案加一<br>这个题目有点需要注意的是：<strong>如果有一行没有放棋子那么还可以在下一行来放，这个需要手动添加</strong>。</p></blockquote><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">10</span>;</span><br><span class="line"><span class="type">char</span> g[N][N];</span><br><span class="line"><span class="type">bool</span> col[N];</span><br><span class="line"><span class="type">int</span> n,k;</span><br><span class="line"><span class="type">int</span> ans,cnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(cnt==k) <span class="comment">//放完了就代表多了一种方法</span></span><br><span class="line">    &#123;</span><br><span class="line">        ans++;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(u&gt;=n) <span class="keyword">return</span> ; <span class="comment">//如果遍历完了还没有放完，就代表着这一种方法不行</span></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) <span class="comment">//遍历第 u 的每一列</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(g[u][i]==<span class="string">&#x27;#&#x27;</span>&amp;&amp;!col[i])</span><br><span class="line">        &#123; <span class="comment">//如果这一行能够放棋子</span></span><br><span class="line">            cnt++;</span><br><span class="line">            col[i]=<span class="number">1</span>;</span><br><span class="line">            <span class="built_in">dfs</span>(u+<span class="number">1</span>); <span class="comment">//那么进入下一行</span></span><br><span class="line">            cnt--; <span class="comment">//恢复现场</span></span><br><span class="line">            col[i]=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dfs</span>(u+<span class="number">1</span>); <span class="comment">//如果这一行不放棋子，那么直接进入下一行</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;n&gt;&gt;k&amp;&amp;n!=<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ans=<span class="number">0</span>,cnt=<span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                cin&gt;&gt;g[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">dfs</span>(<span class="number">0</span>);</span><br><span class="line">        cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 每日一题--队列队 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DFS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2022-09-15队列队每日一题</title>
      <link href="/posts/86c46b56.html"/>
      <url>/posts/86c46b56.html</url>
      
        <content type="html"><![CDATA[<div class="tag link"><a class="link-card" title="力扣 51. N 皇后" href="https://leetcode.cn/problems/n-queens/"><div class="left"><img src="https://img.hipyt.cn/imgs/2022/09/e3f773cfe32f6f4f.jpg"/></div><div class="right"><p class="text">力扣 51. N 皇后</p><p class="url">https://leetcode.cn/problems/n-queens/</p></div></a></div><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>给出一个数 n，在一个 n x n 的矩阵中，摆上 n 个皇后，要求<strong>同一行、同一列、同一个斜线(左右)上只能存在一个皇后，皇后所在地用 ‘Q’ 表示，其他位置用 ‘.’ 表示</strong>，求出所有不同的摆放情况。</p><h2 id="题意解析"><a href="#题意解析" class="headerlink" title="题意解析"></a>题意解析</h2><p>如果采用 DFS 的想法，我们一行一行的枚举，<span class='p red'>对行进行深搜</span>。当我们判断到对 u 行的第 i 列是否能够放皇后的时候，如果能，继续判断第 u+1 行，如此循环。</p><p><br></p><p>因此，我们只需要判断在 <strong>[ u , i ]</strong> 这个点上能不能放皇后，不能就看下一列，能就直接跳到下一行。我们使用 col、dg、udg 三个数组来判断某个位置能不能放放后。</p><p><br></p><p>对于每一列，我们直接看 <strong>col[i]</strong> 是否为 false 即可。<br>我们如何使用 dg、udg 来判断对角线上是否有皇后呢？<br><div class="img-wrap"><div class="img-bg"><img class="img" src="https://www.hualigs.cn/image/6322f6ca87a7e.jpg"/></div></div></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> col[N],dg[N&lt;&lt;<span class="number">1</span>],udg[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> n,vector&lt;string&gt; &amp;res,vector&lt;vector&lt;string&gt;&gt; &amp;ans)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(u==n) <span class="comment">//如果成功放完</span></span><br><span class="line">        &#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(res);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//对于每一列，判断这一列是否能够放一个皇后</span></span><br><span class="line">            <span class="keyword">if</span>(!col[i]&amp;&amp;!dg[i+u]&amp;&amp;!udg[n-u+i])</span><br><span class="line">            &#123;</span><br><span class="line">                res[u][i]=<span class="string">&#x27;Q&#x27;</span>;</span><br><span class="line">                col[i]=dg[i+u]=udg[n-u+i]=<span class="literal">true</span>;</span><br><span class="line">                <span class="built_in">dfs</span>(u+<span class="number">1</span>,n,res,ans);</span><br><span class="line">                col[i]=dg[i+u]=udg[n-u+i]=<span class="literal">false</span>;</span><br><span class="line">                res[u][i]=<span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; <span class="built_in">solveNQueens</span>(<span class="type">int</span> n) </span><br><span class="line">    &#123;</span><br><span class="line">        vector&lt;string&gt; res;</span><br><span class="line">        vector&lt;vector&lt;string&gt;&gt; ans;</span><br><span class="line"></span><br><span class="line">        string s;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) s+=<span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) res.<span class="built_in">push_back</span>(s);</span><br><span class="line">        <span class="comment">//初始化</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">dfs</span>(<span class="number">0</span>,n,res,ans);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 每日一题--队列队 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DFS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2022-09-14队列队每日一题</title>
      <link href="/posts/91ec0f96.html"/>
      <url>/posts/91ec0f96.html</url>
      
        <content type="html"><![CDATA[<div class="tag link"><a class="link-card" title="力扣 1619. 删除某些元素后的数组均值" href="https://leetcode.cn/problems/mean-of-array-after-removing-some-elements/submissions/"><div class="left"><img src="https://img.hipyt.cn/imgs/2022/09/e3f773cfe32f6f4f.jpg"/></div><div class="right"><p class="text">力扣 1619. 删除某些元素后的数组均值</p><p class="url">https://leetcode.cn/problems/mean-of-array-after-removing-some-elements/submissions/</p></div></a></div><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>把一个数组的前 %5 个数和后 %5 个数去掉，剩下的数求平均值。</p><h2 id="题意解析"><a href="#题意解析" class="headerlink" title="题意解析"></a>题意解析</h2><p>太简单略。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">trimMean</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">sort</span>(arr.<span class="built_in">begin</span>(),arr.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=arr.<span class="built_in">size</span>()*<span class="number">0.05</span>;i&lt;arr.<span class="built_in">size</span>()*<span class="number">0.95</span>;i++)</span><br><span class="line">        &#123; <span class="comment">//掐头去尾</span></span><br><span class="line">            cnt+=arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">double</span>)cnt/(arr.<span class="built_in">size</span>()*<span class="number">0.9</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 每日一题--队列队 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 模拟 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2022-09-13队列队每日一题</title>
      <link href="/posts/f43531d6.html"/>
      <url>/posts/f43531d6.html</url>
      
        <content type="html"><![CDATA[<div class="tag link"><a class="link-card" title="力扣 670. 最大交换" href="https://leetcode.cn/problems/maximum-swap/"><div class="left"><img src="https://img.hipyt.cn/imgs/2022/09/e3f773cfe32f6f4f.jpg"/></div><div class="right"><p class="text">力扣 670. 最大交换</p><p class="url">https://leetcode.cn/problems/maximum-swap/</p></div></a></div><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>给定一个非负整数，你至多可以交换一次数字中的<strong>任意两位</strong>。返回你能得到的<span class='p red'>最大值</span>。</p><h2 id="题意解析"><a href="#题意解析" class="headerlink" title="题意解析"></a>题意解析</h2><p>将数字拆分下来存放在数组 v 中，遍历交换任意两个数字，再将其变回数字，用 ans 来记录最大的数字。</p><h2 id="代码-暴力"><a href="#代码-暴力" class="headerlink" title="代码(暴力)"></a>代码(暴力)</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">to_number</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;v)</span></span></span><br><span class="line"><span class="function">    </span>&#123; <span class="comment">//将数组变回数字</span></span><br><span class="line">        <span class="type">int</span> ans=<span class="number">0</span>,cnt=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> x : v) ans+=x*cnt,cnt*=<span class="number">10</span>;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maximumSwap</span><span class="params">(<span class="type">int</span> num)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">        <span class="type">int</span> ans=num;</span><br><span class="line">        <span class="keyword">while</span>(num)</span><br><span class="line">        &#123;</span><br><span class="line">            v.<span class="built_in">push_back</span>(num%<span class="number">10</span>);</span><br><span class="line">            num/=<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;v.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123; <span class="comment">//遍历</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;v.<span class="built_in">size</span>();j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(i==j) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="built_in">swap</span>(v[i],v[j]);</span><br><span class="line">                ans=<span class="built_in">max</span>(ans,<span class="built_in">to_number</span>(v));</span><br><span class="line">                <span class="built_in">swap</span>(v[i],v[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//暴力yyds</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 每日一题--队列队 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 暴力 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2022-09-12未来可期小组每日一题</title>
      <link href="/posts/6ee60c0f.html"/>
      <url>/posts/6ee60c0f.html</url>
      
        <content type="html"><![CDATA[<div class="tag link"><a class="link-card" title="acwing 1762. 牛的洗牌" href="https://www.acwing.com/problem/content/description/1764/"><div class="left"><img src="https://img.hipyt.cn/imgs/2022/09/e3f773cfe32f6f4f.jpg"/></div><div class="right"><p class="text">acwing 1762. 牛的洗牌</p><p class="url">https://www.acwing.com/problem/content/description/1764/</p></div></a></div><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>略<br><br><br><br></p><h2 id="题意解析"><a href="#题意解析" class="headerlink" title="题意解析"></a>题意解析</h2><p>由于给出的顺序是牛被洗牌三次的顺序，我们给出三个数组 a[N] , b[N] , c[N]，b 数组装 id，a 数组记录逆洗牌的顺序，我们需要进行三次逆洗牌，那么每一次洗牌，i 未知的牛都回去 a[i] 的位置。所以三次逆洗牌之后，会回到 a[a[a[i]]] 的 位置。</p><h2 id="代码-c"><a href="#代码-c" class="headerlink" title="代码(c++)"></a>代码(c++)</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">110</span>;</span><br><span class="line"><span class="type">int</span> a[N],b[N],c[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> x,n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) </span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;x;</span><br><span class="line">        a[x]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;b[i];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        c[a[a[a[i]]]]=b[i];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) cout&lt;&lt;c[i]&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 每日一题--未来可期小组 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技巧题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2022-09-11未来可期小组每日一题</title>
      <link href="/posts/7dce357c.html"/>
      <url>/posts/7dce357c.html</url>
      
        <content type="html"><![CDATA[<div class="tag link"><a class="link-card" title="acwing 1761. 阻挡广告牌" href="https://www.acwing.com/problem/content/1763/"><div class="left"><img src="https://img.hipyt.cn/imgs/2022/09/e3f773cfe32f6f4f.jpg"/></div><div class="right"><p class="text">acwing 1761. 阻挡广告牌</p><p class="url">https://www.acwing.com/problem/content/1763/</p></div></a></div><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>有两个矩形广告牌和一辆矩形货车，用坐标表示在二维坐标系中，每个矩形给出左下角和右上角的坐标，两个广告牌有 可能会被矩形货车盖住一部分，求出没有被盖住的广告牌的面积。</p><h2 id="题意解析"><a href="#题意解析" class="headerlink" title="题意解析"></a>题意解析</h2><p>创建一个二维矩阵，对于两个广告牌，我们使其区域中每个数都为 1，让矩形货车范围内的数都变成零，其他数都为零，计算有多少个 1 即可。</p><h2 id="代码-c"><a href="#代码-c" class="headerlink" title="代码(c++)"></a>代码(c++)</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1001</span>;</span><br><span class="line"><span class="type">int</span> a,b,c,d;<span class="comment">//第一个广告牌</span></span><br><span class="line"><span class="type">int</span> e,f,g,h;<span class="comment">//第二个广告牌</span></span><br><span class="line"><span class="type">int</span> i,j,k,l;<span class="comment">//第三个大货车</span></span><br><span class="line"><span class="type">int</span> z[N*<span class="number">2</span>][N*<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;a&gt;&gt;b&gt;&gt;c&gt;&gt;d;</span><br><span class="line">    cin&gt;&gt;e&gt;&gt;f&gt;&gt;g&gt;&gt;h;</span><br><span class="line">    cin&gt;&gt;i&gt;&gt;j&gt;&gt;k&gt;&gt;l;</span><br><span class="line">    a+=N,b+=N,c+=N,d+=N,e+=N,f+=N,g+=N,h+=N,i+=N,j+=N,k+=N,l+=N;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//因为求的是面积所以需要减一</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> x=a;x&lt;c;x++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> y=b;y&lt;d;y++) z[x][y]=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> x=e;x&lt;g;x++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> y=f;y&lt;h;y++) z[x][y]=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> x=i;x&lt;k;x++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> y=j;y&lt;l;y++) z[x][y]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> x=<span class="number">0</span>;x&lt;N*<span class="number">2</span>;x++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> y=<span class="number">0</span>;y&lt;N*<span class="number">2</span>;y++) ans+=z[x][y];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 每日一题--未来可期小组 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技巧题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2022-09-12队列队每日一题</title>
      <link href="/posts/e31d5516.html"/>
      <url>/posts/e31d5516.html</url>
      
        <content type="html"><![CDATA[<div class="tag link"><a class="link-card" title="力扣 1608. 特殊数组的特征值" href="https://leetcode.cn/problems/special-array-with-x-elements-greater-than-or-equal-x/"><div class="left"><img src="https://img.hipyt.cn/imgs/2022/09/e3f773cfe32f6f4f.jpg"/></div><div class="right"><p class="text">力扣 1608. 特殊数组的特征值</p><p class="url">https://leetcode.cn/problems/special-array-with-x-elements-greater-than-or-equal-x/</p></div></a></div><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>给出一个非负数数组，存在一个 x 使数组里面右 x 个数大于等于 x（<strong>x 不必为数组中的数</strong>），求出 x，如果没有则输出-1；</p><h2 id="题意解析"><a href="#题意解析" class="headerlink" title="题意解析"></a>题意解析</h2><p>这个题有个<strong>暴力</strong>做法，题目给的范围是数组的长度是 1 到 100，也就是说，x 的最大值也不肯超过一百，我们可以直接从一百到一遍历，碰到成立的直接输出就行。<br><br><br>其次，我们可以对数组进行降序处理，x 必然为 [1，n] 中的某一个数字，我们枚举 x，如果对于某一个 x，将其插入数组之后，左边有 x 个数大于等于它，右边的数全都小于它，那么 x 成立。否则输出-1；</p><h2 id="代码-暴力"><a href="#代码-暴力" class="headerlink" title="代码(暴力)"></a>代码(暴力)</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">specialArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; n)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">100</span>;i;i--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n.<span class="built_in">size</span>();j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(i&lt;=n[j]) cnt++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(cnt==i) <span class="keyword">return</span> cnt;</span><br><span class="line">            <span class="comment">//暴力yyds</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="代码-排序"><a href="#代码-排序" class="headerlink" title="代码(排序)"></a>代码(排序)</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int specialArray(vector&lt;int&gt;&amp; n) </span><br><span class="line">    &#123;</span><br><span class="line">        sort(n.begin(),n.end(),greater&lt;int&gt;());</span><br><span class="line">        for(int i=1;i&lt;=n.size();i++)</span><br><span class="line">        &#123; /*用代码实现。n[i-1]是第 i 个数，因为是降序，所以 i&lt;=n[i-1] 则有 i 个大于等于 i 的数，也即是 i 比左边的数都小或者相等，</span><br><span class="line">如果 i&gt;n[i] ,则 i 比右边的数都大*/</span><br><span class="line">            </span><br><span class="line">            if(i&lt;=n[i-1]&amp;&amp;(i==n.size()||i&gt;n[i])) return i;</span><br><span class="line">        &#125;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 每日一题--队列队 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 暴力 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2022-09-11队列队每日一题</title>
      <link href="/posts/da65f856.html"/>
      <url>/posts/da65f856.html</url>
      
        <content type="html"><![CDATA[<div class="tag link"><a class="link-card" title="力扣 6172. 严格回文的数字" href="https://leetcode.cn/problems/strictly-palindromic-number/"><div class="left"><img src="https://img.hipyt.cn/imgs/2022/09/e3f773cfe32f6f4f.jpg"/></div><div class="right"><p class="text">力扣 6172. 严格回文的数字</p><p class="url">https://leetcode.cn/problems/strictly-palindromic-number/</p></div></a></div><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>将一个数 n 转化为 b 进制(b 为 2 到 n-2 的整数)，如果在 b 进制下 n 都是回文字符串，那么 n 是严格回文的。是返回 true；否则返回 false。</p><h2 id="题意解析"><a href="#题意解析" class="headerlink" title="题意解析"></a>题意解析</h2><p>直接将 n 的每一个 b 进制表示出来，在一个个判断是否回文，可以枚举。<br><div class="tip info"><p>知识点：进制转换</p></div></p><blockquote><p>这个题目涉及到的就是进制转换，如何将十进制的 n 转换为其他进制？<br>我们需要用除 b 取余法。简单来说，我们将 n%b，将余数保存在数组，再将 n/b。不断地从重复上述操作，最后保存的数组就是将十进制转化的 b 进制数。<br>需要注意的是：<strong>保存的进制数是从左到右看的，而正常的进制数都是从右到左</strong>。</p></blockquote><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">zh</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">while</span>(n)</span><br><span class="line">        &#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(n%b);</span><br><span class="line">            n/=b;</span><br><span class="line">        &#125;<span class="comment">//将 n 转换为 b 进制数，除 b 取余法</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;ans.<span class="built_in">size</span>()/<span class="number">2</span>;i++)</span><br><span class="line">        &#123;<span class="comment">//因为判断回文，正反看都是一样的，所以这里进制数不需要处理</span></span><br><span class="line">            <span class="keyword">if</span>(ans[i]!=ans[ans.<span class="built_in">size</span>()-i<span class="number">-1</span>]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isStrictlyPalindromic</span><span class="params">(<span class="type">int</span> n)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n<span class="number">-2</span>;i++)</span><br><span class="line">        &#123;<span class="comment">//遍历判断回文即可</span></span><br><span class="line">            <span class="keyword">if</span>(!<span class="built_in">zh</span>(n,i)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 每日一题--队列队 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 进制转换 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>力扣第309场周赛---第三题</title>
      <link href="/posts/cdca7fb6.html"/>
      <url>/posts/cdca7fb6.html</url>
      
        <content type="html"><![CDATA[<div class="tag link"><a class="link-card" title="力扣 2401. 最长优雅子数组" href="https://leetcode.cn/problems/longest-nice-subarray/submissions/"><div class="left"><img src="https://img.hipyt.cn/imgs/2022/09/e3f773cfe32f6f4f.jpg"/></div><div class="right"><p class="text">力扣 2401. 最长优雅子数组</p><p class="url">https://leetcode.cn/problems/longest-nice-subarray/submissions/</p></div></a></div><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>给出一个数组，求出最长的优雅子数组数组。<br><em>优雅子数组</em>：对于这个数组中的每一个数，两两相与的结果为 0。</p><h2 id="题意解析"><a href="#题意解析" class="headerlink" title="题意解析"></a>题意解析</h2><p>很经典的双指针的题目。<br>我们定义 l，r 为子区间的左右端点，r 不断的遍历数组。对于每一次遍历，定义 x 指针，从 r 开始向左移动，<span class='p red'>如果存在与 r 点的数 & 不为零的，那么 l 就更新为 x++</span>。每一次都更新 ans 的值。</p><p><br><br><br></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">longestNiceSubarray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;   </span><br><span class="line">        <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">0</span>,r=<span class="number">0</span>;r&lt;nums.<span class="built_in">size</span>();r++) <span class="comment">//遍历右端点</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> x=r;</span><br><span class="line">            <span class="keyword">while</span>(x!=l)</span><br><span class="line">            &#123;</span><br><span class="line">                x--;</span><br><span class="line">                <span class="keyword">if</span>(nums[x]&amp;nums[r]) <span class="comment">//找到以 r 为右端点的最长的字数组</span></span><br><span class="line">                &#123;</span><br><span class="line">                    l=++x;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ans=<span class="built_in">max</span>(ans,r-l+<span class="number">1</span>);  <span class="comment">//更新答案</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 力扣周赛 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>力扣第309场周赛---第二题</title>
      <link href="/posts/80d4dce4.html"/>
      <url>/posts/80d4dce4.html</url>
      
        <content type="html"><![CDATA[<div class="tag link"><a class="link-card" title="力扣 6168. 恰好移动 k 步到达某一位置的方法数目" href="https://leetcode.cn/problems/number-of-ways-to-reach-a-position-after-exactly-k-steps/"><div class="left"><img src="https://img.hipyt.cn/imgs/2022/09/e3f773cfe32f6f4f.jpg"/></div><div class="right"><p class="text">力扣 6168. 恰好移动 k 步到达某一位置的方法数目</p><p class="url">https://leetcode.cn/problems/number-of-ways-to-reach-a-position-after-exactly-k-steps/</p></div></a></div><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>给一个起点 s 和终点 e，要求你走 k 步正好从 s到达 e，每一次可以可以向左或者向右走(<strong>走过终点再往回走也行</strong>)，求方案数 MOD 1e9+7 的结果。<br><div class="tip warning faa-parent animated-hover"><p class="faa-horizontal">注意数轴可能有负数</p></div></p><h2 id="题意解析"><a href="#题意解析" class="headerlink" title="题意解析"></a>题意解析</h2><p>使用动态规划，</p><blockquote><ol><li><span class='p red'>dp[i][j]表示走了 i 步，当前位置在 j 的时候的方案数</span></li><li><span class='p red'>初始值 dp[0][s]=1</span></li><li><span class='p red'>状态转移方程：f[i][j] = f[i-1][j-1] + f[i-1][j+1]</span>，表示上一步从左到右和从右到左到达当前位置的方案数总和</li></ol></blockquote><div class="tip warning faa-parent animated-hover"><p class="faa-horizontal">考虑到负数，我们给起点和终点加一个偏移量</p></div><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numberOfWays</span><span class="params">(<span class="type">int</span> s, <span class="type">int</span> e, <span class="type">int</span> k)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> dp[<span class="number">1010</span>][<span class="number">2010</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> MOD=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line">        s+=<span class="number">500</span>; e+=<span class="number">500</span>; <span class="comment">//偏移量</span></span><br><span class="line">        dp[<span class="number">0</span>][s]=<span class="number">1</span>; <span class="comment">//初始化</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=k;i++) <span class="comment">//一共只能走 k 步</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;<span class="number">2005</span>;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                dp[i][j]+=dp[i<span class="number">-1</span>][j<span class="number">-1</span>]; <span class="comment">//从右走到达当前位置</span></span><br><span class="line">                dp[i][j]=(dp[i][j]+dp[i<span class="number">-1</span>][j+<span class="number">1</span>])%MOD; <span class="comment">//从左走到达当前位置</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[k][e];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 力扣周赛 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>力扣第309场周赛---第一题</title>
      <link href="/posts/b0c2303c.html"/>
      <url>/posts/b0c2303c.html</url>
      
        <content type="html"><![CDATA[<div class="tag link"><a class="link-card" title="6167. 检查相同字母间的距离" href="https://leetcode.cn/problems/check-distances-between-same-letters/"><div class="left"><img src="https://img.hipyt.cn/imgs/2022/09/e3f773cfe32f6f4f.jpg"/></div><div class="right"><p class="text">6167. 检查相同字母间的距离</p><p class="url">https://leetcode.cn/problems/check-distances-between-same-letters/</p></div></a></div><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>给你一个字符串和一个数组，(字母 a 对应数组的下标零等等)，判断每两个相同的字母之间的距离是否与给出的数组的相应字母的下标的数相同。</p><blockquote><p>例如：abba ，dis[2,3,4,0,……]，a 对应 0，则我们需要判断 dis[0]是否等于 2。</p></blockquote><h2 id="题意解析"><a href="#题意解析" class="headerlink" title="题意解析"></a>题意解析</h2><p>这道题可以使用双指针的方法。</p><blockquote><p>定义一个双指针 i，j，每当 i 指向某一个字符的时候，我们用 j <strong>找到它后面与它相同的字母</strong>。<br>然后计算两者之间的距离是否与 dis 给出的数字相同。</p></blockquote><p><br><br><br></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">checkDistances</span><span class="params">(string s, vector&lt;<span class="type">int</span>&gt;&amp; distance)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.<span class="built_in">size</span>()<span class="number">-1</span>;i++) <span class="comment">//遍历每一个单词</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j=i+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(j&lt;s.<span class="built_in">size</span>()&amp;&amp;s[j]!=s[i]) j++; <span class="comment">//找到后面与它相同的字母</span></span><br><span class="line">            <span class="keyword">if</span>(s[i]==s[j]) <span class="keyword">if</span>(j-i<span class="number">-1</span>!=distance[s[i]-<span class="string">&#x27;a&#x27;</span>]) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//计算距离</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 力扣周赛 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2022-09-10未来可期小组每日一题</title>
      <link href="/posts/7329ddad.html"/>
      <url>/posts/7329ddad.html</url>
      
        <content type="html"><![CDATA[<div class="tag link"><a class="link-card" title="acwing 1469. 围栏规划" href="https://www.acwing.com/problem/content/1471/"><div class="left"><img src="https://img.hipyt.cn/imgs/2022/09/e3f773cfe32f6f4f.jpg"/></div><div class="right"><p class="text">acwing 1469. 围栏规划</p><p class="url">https://www.acwing.com/problem/content/1471/</p></div></a></div><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>一共有 n 个点，每个点都会给出二维坐标，然后再给出 m 个关系，又关系的点属于同一个连通块，每一个连通块都有一个平行于坐标轴的矩形包围起来，求出<strong>最小的矩形的周长</strong>。<br><br><br><br></p><h2 id="题意解析"><a href="#题意解析" class="headerlink" title="题意解析"></a>题意解析</h2><p>这个题目信息是给出了若干个连通块，我们需要对每一个连通块进行处理。对此我们可以使用并查集对连通块进行处理。</p><blockquote><ol><li>我们用并查集维护连通块</li><li>对于每一个连通块，我们维护其最大和最小的 x 和 y</li><li>最后计算最小的矩形周长</li></ol></blockquote><p><br><br><br></p><h2 id="代码-c"><a href="#代码-c" class="headerlink" title="代码(c++)"></a>代码(c++)</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line">map&lt;<span class="type">int</span>,PII&gt; mp;</span><br><span class="line"><span class="type">int</span> p[N];</span><br><span class="line"><span class="type">int</span> ans1[N],ans2[N],ans3[N],ans4[N]; <span class="comment">//存放每一个连通块的最小 x，y 坐标和最大 x，y 坐标</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> <span class="comment">//并查集</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x!=p[x]) p[x]=<span class="built_in">find</span>(p[x]);</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//找到题目所给的几个联通块，并求出围着这些联通块的最小周长</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,m,l,r;</span><br><span class="line">    <span class="built_in">memset</span>(ans1,<span class="number">-0x3f</span>,<span class="keyword">sizeof</span> ans1); <span class="comment">//初始化</span></span><br><span class="line">    <span class="built_in">memset</span>(ans2,<span class="number">-0x3f</span>,<span class="keyword">sizeof</span> ans2);</span><br><span class="line">    <span class="built_in">memset</span>(ans3,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> ans3);</span><br><span class="line">    <span class="built_in">memset</span>(ans4,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> ans4);</span><br><span class="line">    </span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n;i++) p[i]=i;  <span class="comment">//初始化</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123; <span class="comment">//记录每一个点的二维坐标</span></span><br><span class="line">        cin&gt;&gt;l&gt;&gt;r;</span><br><span class="line">        mp[i]=&#123;l,r&#125;; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123; </span><br><span class="line">        cin&gt;&gt;l&gt;&gt;r; <span class="comment">//维护连通块</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">find</span>(l)!=<span class="built_in">find</span>(r)) p[<span class="built_in">find</span>(r)]=<span class="built_in">find</span>(l); <span class="comment">//将有关系的弄到一起</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> pa=<span class="built_in">find</span>(i); <span class="comment">//对于每一个 i，如果其处于同一个连通块当中，那么 pa 值一定相同</span></span><br><span class="line">        ans1[pa]=<span class="built_in">max</span>(ans1[pa],mp[i].first); <span class="comment">//找每个连通块的最大坐标</span></span><br><span class="line">        ans2[pa]=<span class="built_in">max</span>(ans2[pa],mp[i].second);</span><br><span class="line">        </span><br><span class="line">        ans3[pa]=<span class="built_in">min</span>(ans3[pa],mp[i].first);  <span class="comment">//找最小坐标</span></span><br><span class="line">        ans4[pa]=<span class="built_in">min</span>(ans4[pa],mp[i].second);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> mx=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(ans1[i]==<span class="number">-0x3f3f3f3f</span>||ans1[i]==<span class="number">-0x3f3f3f3f</span>||ans3[i]==<span class="number">0x3f3f3f3f</span>||ans4[i]==<span class="number">0x3f3f3f3f</span>) <span class="keyword">continue</span>;</span><br><span class="line">        mx=<span class="built_in">min</span>(mx,<span class="number">2</span>*(ans1[i]-ans3[i]+ans2[i]-ans4[i])); <span class="comment">//对于每一个联通块求出最小周长，并求总的最小周长</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cout&lt;&lt;mx;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 每日一题--未来可期小组 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图 </tag>
            
            <tag> 并查集 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2022-09-10队列队每日一题</title>
      <link href="/posts/cd4d9c96.html"/>
      <url>/posts/cd4d9c96.html</url>
      
        <content type="html"><![CDATA[<div class="tag link"><a class="link-card" title="力扣 669. 修剪二叉搜索树" href="https://leetcode.cn/problems/trim-a-binary-search-tree/submissions/"><div class="left"><img src="https://img.hipyt.cn/imgs/2022/09/e3f773cfe32f6f4f.jpg"/></div><div class="right"><p class="text">力扣 669. 修剪二叉搜索树</p><p class="url">https://leetcode.cn/problems/trim-a-binary-search-tree/submissions/</p></div></a></div><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>题目给出的是一个搜索二叉树，并且给出了一个区间 [ low , high ] ，要求我们将树上不在区间范围内的叶子都剪掉，并且保证结构不被破坏，右子节点还是右子节点，同理左还是左。</p><h2 id="题意解析"><a href="#题意解析" class="headerlink" title="题意解析"></a>题意解析</h2><div class="tip info"><p>搜索二叉树的左子节点值小于根节点值，右子节点值大于根节点值</p></div><div class="tabs" id="test1"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test1-1"><i>递归做法</i></button></li><li class="tab"><button type="button" data-href="#test1-2"><i>迭代做法</i></button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test1-1"><blockquote><ol><li>我们将原函数当作递归函数，表示<strong>对子节点修剪后的结果</strong>。</li><li>如果当前节点为空，返回空。</li><li>如果<strong>当前节点的值小于 low</strong>，则当前节点的左节点及其所有子节点都小于 low，我们<strong>递归当前节点的右节点</strong>；</li><li>同理如果<strong>当前节点的值大于 high，我们递归左节点</strong>。</li><li>除此之外，符合要求的，我们将其左节点和右节点更新。</li></ol></blockquote><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-2"><blockquote><ol><li>我们首先找到符合标准也就是在范围之内的结点，将其作为根节点</li><li>对于某一个符合要求的节点 node，我们先对左子树 left 进行修剪<ol><li>如果 left 的值小于 low，则证明 left 和其左子树都不符合要求，故我们将 node 的左节点设置为 left 的右节点</li><li>如果 left 的值大于等于 low，那么我们继续对 left 的左节点进行处理</li></ol></li><li>右节点同理左节点</li></ol>    </blockquote><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><div class="tabs" id="test2"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test2-1"><i>递归做法</i></button></li><li class="tab"><button type="button" data-href="#test2-2"><i>迭代做法</i></button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test2-1"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">trimBST</span><span class="params">(TreeNode* root, <span class="type">int</span> low, <span class="type">int</span> high)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;val&lt;low) <span class="keyword">return</span> <span class="built_in">trimBST</span>(root-&gt;right,low,high); <span class="comment">//如果节点值小于low，我们找右节点</span></span><br><span class="line">        <span class="keyword">if</span>(root-&gt;val&gt;high) <span class="keyword">return</span> <span class="built_in">trimBST</span>(root-&gt;left,low,high); <span class="comment">//同理</span></span><br><span class="line"></span><br><span class="line">        root-&gt;right=<span class="built_in">trimBST</span>(root-&gt;right,low,high);  <span class="comment">//符合要求就正常更新</span></span><br><span class="line">        root-&gt;left=<span class="built_in">trimBST</span>(root-&gt;left,low,high);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test2-2"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">trimBST</span><span class="params">(TreeNode* root, <span class="type">int</span> low, <span class="type">int</span> high)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(root) <span class="comment">//首先找到符合要求的根节点</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(low&lt;=root-&gt;val&amp;&amp;root-&gt;val&lt;=high) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span>(root-&gt;val&lt;low) root=root-&gt;right;</span><br><span class="line">            <span class="keyword">if</span>(root-&gt;val&gt;high) root=root-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> dian=root;</span><br><span class="line">        <span class="keyword">while</span>(dian-&gt;left) <span class="comment">//对左子树剪枝</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(dian-&gt;left-&gt;val&lt;low) dian-&gt;left=dian-&gt;left-&gt;right;</span><br><span class="line">            <span class="keyword">else</span> dian=dian-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        dian=root;</span><br><span class="line">        <span class="keyword">while</span>(dian-&gt;right) <span class="comment">//对右子树剪枝</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(dian-&gt;right-&gt;val&gt;high) dian-&gt;right=dian-&gt;right-&gt;left;</span><br><span class="line">            <span class="keyword">else</span> dian=dian-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div>]]></content>
      
      
      <categories>
          
          <category> 每日一题--队列队 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 搜索二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2022-09-09队列队每日一题</title>
      <link href="/posts/f8553482.html"/>
      <url>/posts/f8553482.html</url>
      
        <content type="html"><![CDATA[<div class="tag link"><a class="link-card" title="力扣 1598. 文件夹操作日志搜集器" href="https://leetcode.cn/problems/crawler-log-folder/submissions/"><div class="left"><img src="https://img.hipyt.cn/imgs/2022/09/e3f773cfe32f6f4f.jpg"/></div><div class="right"><p class="text">力扣 1598. 文件夹操作日志搜集器</p><p class="url">https://leetcode.cn/problems/crawler-log-folder/submissions/</p></div></a></div><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>太简单略</p><h2 id="题意解析"><a href="#题意解析" class="headerlink" title="题意解析"></a>题意解析</h2><p>这个题目没有思路，<span class='p red'>但是全是坑</span>。写的时候注意。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minOperations</span><span class="params">(vector&lt;string&gt;&amp; logs)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">       <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">auto</span> x : logs)</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="keyword">if</span>(x[<span class="number">0</span>]!=<span class="string">&#x27;.&#x27;</span>&amp;&amp;x[<span class="number">1</span>]!=<span class="string">&#x27;.&#x27;</span>) ans++;</span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span>(x[<span class="number">0</span>]==<span class="string">&#x27;.&#x27;</span>&amp;&amp;x[<span class="number">1</span>]==<span class="string">&#x27;.&#x27;</span>) </span><br><span class="line">           &#123;</span><br><span class="line">               <span class="comment">//第一个坑</span></span><br><span class="line">               <span class="keyword">if</span>(ans) ans--;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//第二个坑</span></span><br><span class="line">       <span class="keyword">return</span> <span class="built_in">max</span>(ans,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 每日一题--队列队 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技巧题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2022-09-08未来可期小组每日一题</title>
      <link href="/posts/f5cc9e8f.html"/>
      <url>/posts/f5cc9e8f.html</url>
      
        <content type="html"><![CDATA[<div class="tag link"><a class="link-card" title="acwing 1467. 奶牛朝向" href="https://www.acwing.com/activity/content/problem/content/6322/"><div class="left"><img src="https://img.hipyt.cn/imgs/2022/09/e3f773cfe32f6f4f.jpg"/></div><div class="right"><p class="text">acwing 1467. 奶牛朝向</p><p class="url">https://www.acwing.com/activity/content/problem/content/6322/</p></div></a></div><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>给出一个数 n 和 n x n 的二维矩阵，每次可以翻转任意一行或者一列，我们希望这个二维矩阵可以所有的数全部相同，但是始终会有一个数与其他的所有数不同，请找出这个数并值<strong>输出他的坐标</strong>，如果没有输出” -1 “。</p><h2 id="题意解析"><a href="#题意解析" class="headerlink" title="题意解析"></a>题意解析</h2><p>对于这个题目，我们首先将这个矩阵的<strong>第一行和第一列里面所有 1 所在的行或者列全部转换一下</strong>。换句话说，也就是要保证第一行和第一列全部为 0，并且我们知道每次必须翻转一行或者一列，所以需要将 1所在的行或者列翻转。</p><p><p>我们统计矩阵中 1 的数量 cnt，此时会出现四种情况</p><br><div class="tip info"><p>统计 1 的数量使用了二维前缀和的技巧，后面计算 1 的数量也是，可以优化时间</p></div></p><blockquote><ol><li>cnt == (n-1)<sup>2</sup> ， 此时除了第一行和第一列之外其他的数全是 1，这也就意味着不同的那个数是的坐标是(1，1)。</li><li>cnt == 1 ， 此时我们遍历矩阵，找到那个唯一一个 1 的位置 (i，j)。</li><li>cnt == n-1 ， 这个时候我们遍历第一行和第一列，判断那 n-1 个 1 处于哪一行或者那一列，那么此时唯一一个不同的位置为(i，1)或者(1，i)。</li><li>如果以上三者都不是那么就输出”-1”。</li></ol></blockquote><h2 id="代码-c"><a href="#代码-c" class="headerlink" title="代码(c++)"></a>代码(c++)</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e3</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">char</span> g[N][N];</span><br><span class="line"><span class="type">bool</span> st[N][N];</span><br><span class="line"><span class="type">int</span> s[N][N];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,g[i]+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++) st[i][j]=g[i][j]==<span class="string">&#x27;R&#x27;</span>; <span class="comment">//转换成二进制矩阵</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="comment">//将第一列翻转</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(st[i][<span class="number">1</span>]) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++) st[i][j]^=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="comment">//将第一行翻转</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(st[<span class="number">1</span>][i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++) st[j][i]^=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="comment">//计算二维前缀和</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">s[i][j]=s[i<span class="number">-1</span>][j]+s[i][j<span class="number">-1</span>]-s[i<span class="number">-1</span>][j<span class="number">-1</span>]+st[i][j]; </span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> cnt=s[n][n]-s[<span class="number">1</span>][n]-s[n][<span class="number">1</span>]+s[<span class="number">1</span>][<span class="number">1</span>]; <span class="comment">//计算1的数量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(cnt==(n<span class="number">-1</span>)*(n<span class="number">-1</span>))  <span class="comment">//第一种情况</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %d&quot;</span>,<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(cnt==<span class="number">1</span>) <span class="comment">//第二种情况</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(st[i][j])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d %d&quot;</span>,i,j);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(cnt==n<span class="number">-1</span>) <span class="comment">//第三种情况</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i][n]-s[i<span class="number">-1</span>][n]==n<span class="number">-1</span>)  <span class="comment">//计算哪一行的1的数量为n-1</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d %d&quot;</span>,i,<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(s[n][i]-s[n][i<span class="number">-1</span>]==n<span class="number">-1</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d %d&quot;</span>,<span class="number">1</span>,i);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,<span class="number">-1</span>); <span class="comment">//第四种情况</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 每日一题--未来可期小组 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技巧题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2022-09-08队列队每日一题</title>
      <link href="/posts/ef7d5042.html"/>
      <url>/posts/ef7d5042.html</url>
      
        <content type="html"><![CDATA[<div class="tag link"><a class="link-card" title="力扣 667. 优美的排列 II" href="https://leetcode.cn/problems/beautiful-arrangement-ii/"><div class="left"><img src="https://img.hipyt.cn/imgs/2022/09/e3f773cfe32f6f4f.jpg"/></div><div class="right"><p class="text">力扣 667. 优美的排列 II</p><p class="url">https://leetcode.cn/problems/beautiful-arrangement-ii/</p></div></a></div><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p><p style="text-indent: 2em">给出一个 n 和 k 两个数，要求输出一个数组</p></p><p><p style="text-indent: 2em">保证:</p></p><blockquote><ol><li>answer = [a1, a2, a3, … , an]，数组里面的 n 个数互不相同</li><li>[|a1 - a2|, |a2 - a3|, |a3 - a4|, … , |an-1 - an|]，这个数组里面有 k 个不同的整数</li></ol></blockquote><p><br><br><br></p><h2 id="题意解析"><a href="#题意解析" class="headerlink" title="题意解析"></a>题意解析</h2><p>这种题目需要你去寻找其中的规律，这道题的规律：<span class='p red'>在前 0 到 k 的范围内，下标为偶数的依次填入 1、2、3...... ，下标为奇数的依次填入 k+1、k、k-1...... ，后面则依次顺序填入即可</span><br><br><br><br></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">constructArray</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ans</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="type">int</span> l=<span class="number">1</span>,r=k+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=k;i++) </span><br><span class="line">        &#123; <span class="comment">//找规律，前k个数，偶数下标填1.2.3..，奇数下标填k+1.k.k-1..</span></span><br><span class="line">            <span class="keyword">if</span>(i%<span class="number">2</span>) ans[i]=r--;</span><br><span class="line">            <span class="keyword">else</span> ans[i]=l++; </span><br><span class="line">        &#125; <span class="comment">//后k个数按顺序填入</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=k+<span class="number">2</span>;i&lt;=n;i++) ans[i<span class="number">-1</span>]=i;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 每日一题--队列队 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技巧题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2022-09-07队列队每日一题</title>
      <link href="/posts/33e74802.html"/>
      <url>/posts/33e74802.html</url>
      
        <content type="html"><![CDATA[<div class="tag link"><a class="link-card" title="力扣 1592. 重新排列单词间的空格" href="https://leetcode.cn/problems/rearrange-spaces-between-words/"><div class="left"><img src="https://img.hipyt.cn/imgs/2022/09/e3f773cfe32f6f4f.jpg"/></div><div class="right"><p class="text">力扣 1592. 重新排列单词间的空格</p><p class="url">https://leetcode.cn/problems/rearrange-spaces-between-words/</p></div></a></div><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>给一个被若干个空格包围着的单词组成的字符串 text，将所有的空格均匀地分配给每一个单词之间，多余的空格放到末尾，处理完之后的 text 长度与之前一样(<strong>text 至少包含一个单词</strong>)。</p><h2 id="题意解析"><a href="#题意解析" class="headerlink" title="题意解析"></a>题意解析</h2><p>一个简单的模拟题，我们将单词全部提取出来放到一个集合当中，统计空格个数并且均匀分配，最后将多余的空格放到末尾。提取单词这里用到了双指针的思想。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">reorderSpaces</span><span class="params">(string t)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        vector&lt;string&gt; s;</span><br><span class="line">        <span class="type">int</span> space=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;i&lt;t.<span class="built_in">size</span>();i++) <span class="comment">//双指针提取单词</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(t[i]!=<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                j=i;</span><br><span class="line">                <span class="keyword">while</span>(j&lt;t.<span class="built_in">size</span>()&amp;&amp;t[j]!=<span class="string">&#x27; &#x27;</span>) j++;</span><br><span class="line">                <span class="comment">// cout&lt;&lt;i&lt;&lt;&#x27; &#x27;&lt;&lt;j&lt;&lt;&#x27; &#x27;&lt;&lt;t.substr(i,j-i)&lt;&lt;endl;</span></span><br><span class="line">                s.<span class="built_in">push_back</span>(t.<span class="built_in">substr</span>(i,j-i));</span><br><span class="line">                i=j;</span><br><span class="line">            &#125;</span><br><span class="line">            space+=t[i]==<span class="string">&#x27; &#x27;</span>; <span class="comment">//统计空格数量</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> n=s.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">1</span>) <span class="comment">//特判</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function">string <span class="title">out</span><span class="params">(space,<span class="string">&#x27; &#x27;</span>)</span></span>;</span><br><span class="line">            <span class="keyword">return</span> s[<span class="number">0</span>]+out;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">string <span class="title">in</span><span class="params">(space/(n<span class="number">-1</span>),<span class="string">&#x27; &#x27;</span>)</span>,<span class="title">out</span><span class="params">(space%(n<span class="number">-1</span>),<span class="string">&#x27; &#x27;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        t=<span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.<span class="built_in">size</span>()<span class="number">-1</span>;i++) t+=s[i]+in;  </span><br><span class="line">        t+=s[n<span class="number">-1</span>]+out;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 每日一题--队列队 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 双指针 </tag>
            
            <tag> 字符串处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2022-09-06未来可期小组每日一题</title>
      <link href="/posts/a4a3aae1.html"/>
      <url>/posts/a4a3aae1.html</url>
      
        <content type="html"><![CDATA[<div class="tag link"><a class="link-card" title="acwing 1471. 牛奶工厂" href="https://www.acwing.com/problem/content/1473/"><div class="left"><img src="https://img.hipyt.cn/imgs/2022/09/e3f773cfe32f6f4f.jpg"/></div><div class="right"><p class="text">acwing 1471. 牛奶工厂</p><p class="url">https://www.acwing.com/problem/content/1473/</p></div></a></div><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>给出 n 个点，一共有 n-1 条边，问是否存在一个点 i，使得所有其它点能够直接或间接(<strong>经过其他点到达点 i 或者直达点 i </strong>)的到达点 i，如果有，请输出最小的 i。</p><h2 id="题意解析"><a href="#题意解析" class="headerlink" title="题意解析"></a>题意解析</h2><p>最容易想到的方法就是用邻接表存储图，建一个哈希表，将第一个点到最后一个点所能到达的所有点的对应键值++。最后遍历哈希表，找到键值为 n-1 的点，也即是有除它之外的所有点都能够到达它。这里有个小细节就是哈希表可以使用 map，因为 map 可以自动排序，我们只需要从头遍历每一个点对应的键值是否为 n-1，然后输出，这就是最小的 i。</p><p>当然也有其他方法可以做，有兴趣可以点击题目链接去看看其他的题解。</p><h2 id="代码-c"><a href="#代码-c" class="headerlink" title="代码(c++)"></a>代码(c++)</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> h[N],e[N],ne[N],idx;</span><br><span class="line">map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; mp;</span><br><span class="line"><span class="type">int</span> n,m; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx]=b; ne[idx]=h[a]; h[a]=idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt;q;</span><br><span class="line">    q.<span class="built_in">push</span>(u);</span><br><span class="line">    <span class="keyword">while</span>(q.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t=q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=h[t];i!=<span class="number">-1</span>;i=ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            mp[e[i]]++;</span><br><span class="line">            q.<span class="built_in">push</span>(e[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a,b;</span><br><span class="line">        cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">        <span class="built_in">add</span>(a,b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">bfs</span>(i);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> x : mp)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(x.second==n<span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cout&lt;&lt;x.first&lt;&lt;endl;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;<span class="number">-1</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 每日一题--未来可期小组 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图 </tag>
            
            <tag> 图的遍历 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2022-09-06队列队每日一题</title>
      <link href="/posts/24cf2cc2.html"/>
      <url>/posts/24cf2cc2.html</url>
      
        <content type="html"><![CDATA[<div class="tag link"><a class="link-card" title="力扣 828. 统计子串中的唯一字符" href="https://leetcode.cn/problems/count-unique-characters-of-all-substrings-of-a-given-string/"><div class="left"><img src="https://img.hipyt.cn/imgs/2022/09/e3f773cfe32f6f4f.jpg"/></div><div class="right"><p class="text">力扣 828. 统计子串中的唯一字符</p><p class="url">https://leetcode.cn/problems/count-unique-characters-of-all-substrings-of-a-given-string/</p></div></a></div><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>给出字符串 s，假设 str 为 s 的一个字数组，sum 为 str 中单个字符的数量(<span class='p red'>只出现过一次的字母</span>)。求出 s 的所有子字符串的 sum 的总和。</p><h2 id="题意解析"><a href="#题意解析" class="headerlink" title="题意解析"></a>题意解析</h2><div class="tip info"><p>参考题解：<a href="https://leetcode.cn/problems/count-unique-characters-of-all-substrings-of-a-given-string/solution/c-you-li-zi-yi-dong-by-smilyt_/">https://leetcode.cn/problems/count-unique-characters-of-all-substrings-of-a-given-string/solution/c-you-li-zi-yi-dong-by-smilyt_/</a></p></div><p>对于这个题目，我们不能够被题目误导，我们从每一个字母来看，<span class='p red'>看每一个字母能够有效的出现在多少个子字符串中</span>，我们称其为这个字母的<span class='p red'>贡献</span>。那么我们只需要求出所有的字母的贡献即可。</p><blockquote><p>对于某一个字母的贡献，我们先找出其有效的区间(<strong>区间内只包含一个该字符</strong>)，假设区间为 <strong>[ l , r ] </strong>，该字母在位置 i ( <strong>l &lt;= i &lt;= r</strong> ) 处。那么由排列组合可以知道，其贡献为：<strong>( i - l )x( r - i )</strong>。也就是 该字母左边的单词个数(加上该字母) 乘 该字母右边的单词个数(不包括该字母)。</p><p>怎么求有效区间？<br>我们用 l [N] 数组记录每一个字母的有效左边界，用 r [N] 数组记录每一个字母的有效右边界，用 last [26] 数组记录上一次该字母出现的位置。<br>对于左边界，我们从左往右遍历，对于有边界，我们从右往左遍历。 </p></blockquote><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">uniqueLetterString</span><span class="params">(string s)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> N=s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> l[N],r[N],last1[<span class="number">26</span>],last2[<span class="number">26</span>]; </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++) last1[i]=<span class="number">-1</span>,last2[i]=N;</span><br><span class="line">        <span class="comment">//last1 记录左边界，last2 记录右边界        </span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//从左到右遍历，l 记录左边界，last1 记录单词出现的位置，用于下一次记录左边界</span></span><br><span class="line">            l[i]=last1[s[i]-<span class="string">&#x27;A&#x27;</span>]; </span><br><span class="line">            last1[s[i]-<span class="string">&#x27;A&#x27;</span>]=i;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//从右到左遍历，同上</span></span><br><span class="line">            r[N-i<span class="number">-1</span>]=last2[s[N-i<span class="number">-1</span>]-<span class="string">&#x27;A&#x27;</span>];</span><br><span class="line">            last2[s[N-i<span class="number">-1</span>]-<span class="string">&#x27;A&#x27;</span>]=N-i<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++) ans+=(i-l[i])*(r[i]-i); <span class="comment">//所有字母的贡献之和就是答案</span></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 每日一题--队列队 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2022-09-05未来可期小组每日一题</title>
      <link href="/posts/b78b9392.html"/>
      <url>/posts/b78b9392.html</url>
      
        <content type="html"><![CDATA[<div class="tag link"><a class="link-card" title="acwing 1470. 水桶传递队列" href="https://www.acwing.com/problem/content/1472/"><div class="left"><img src="https://img.hipyt.cn/imgs/2022/09/e3f773cfe32f6f4f.jpg"/></div><div class="right"><p class="text">acwing 1470. 水桶传递队列</p><p class="url">https://www.acwing.com/problem/content/1472/</p></div></a></div><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>给出一个 10 X 10 的字符串矩阵，’.’，’L’，’B’，’R’，分别表示可以走的点，湖，烧着的牛棚，障碍物。障碍物的点不能经过，答案输出一个 L 到 B 的最短路径。</p><h2 id="题意解析"><a href="#题意解析" class="headerlink" title="题意解析"></a>题意解析</h2><p>一眼看到这个题目的时候，第一时间想起了 BFS，对于走迷宫一类的问题很好解决。对于这个题目，我们以 L 的坐标为为起点，当碰到 B 的时候，就是答案。<br><div class="tip warning faa-parent animated-hover"><p class="faa-horizontal">如果忘记了点击<a href="https://www.acwing.com/video/276/">这里</a>。</p></div></p><h2 id="代码-c"><a href="#代码-c" class="headerlink" title="代码(c++)"></a>代码(c++)</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;PII;</span><br><span class="line"><span class="type">char</span> g[<span class="number">15</span>][<span class="number">15</span>];</span><br><span class="line"><span class="type">int</span> ans[<span class="number">15</span>][<span class="number">15</span>];</span><br><span class="line"><span class="type">bool</span> st[<span class="number">15</span>][<span class="number">15</span>]; <span class="comment">//判断是否走过</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> dx[]=&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>&#125;,dy[]=&#123;<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span>。<span class="comment">//a，b 表示起点(L)坐标</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    queue&lt;PII&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(&#123;a,b&#125;);</span><br><span class="line">    st[a][b]=<span class="number">1</span>;  <span class="comment">//标记走过</span></span><br><span class="line">    <span class="keyword">while</span>(q.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x=q.<span class="built_in">front</span>().first,y=q.<span class="built_in">front</span>().second;</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> xx=x+dx[i],yy=y+dy[i];</span><br><span class="line">            <span class="keyword">if</span>(xx&lt;<span class="number">0</span>||yy&lt;<span class="number">0</span>||xx&gt;<span class="number">9</span>||yy&gt;<span class="number">9</span>||st[xx][yy]||g[xx][yy]==<span class="string">&#x27;R&#x27;</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(g[xx][yy]==<span class="string">&#x27;B&#x27;</span>)</span><br><span class="line">            &#123;<span class="comment">//如果当前点的上下左右某一个点是&#x27;B&#x27;，就证明已经走完了，那么我们直接返回答案</span></span><br><span class="line">                cout&lt;&lt;ans[x][y];</span><br><span class="line">                <span class="keyword">return</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">            ans[xx][yy]=ans[x][y]+<span class="number">1</span>;</span><br><span class="line">            st[xx][yy]=<span class="number">1</span>;</span><br><span class="line">            q.<span class="built_in">push</span>(&#123;xx,yy&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> x,y;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">10</span>;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            cin&gt;&gt;g[i][j];</span><br><span class="line">            <span class="keyword">if</span>(g[i][j]==<span class="string">&#x27;L&#x27;</span>) x=i,y=j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">bfs</span>(x,y);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 每日一题--未来可期小组 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BFS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2022-09-05队列队每日一题</title>
      <link href="/posts/1db78182.html"/>
      <url>/posts/1db78182.html</url>
      
        <content type="html"><![CDATA[<div class="tag link"><a class="link-card" title="力扣 6168. 恰好移动 k 步到达某一位置的方法数目" href="https://leetcode.cn/problems/number-of-ways-to-reach-a-position-after-exactly-k-steps/"><div class="left"><img src="https://img.hipyt.cn/imgs/2022/09/e3f773cfe32f6f4f.jpg"/></div><div class="right"><p class="text">力扣 6168. 恰好移动 k 步到达某一位置的方法数目</p><p class="url">https://leetcode.cn/problems/number-of-ways-to-reach-a-position-after-exactly-k-steps/</p></div></a></div><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>给一个起点 s 和终点 e，要求你走 k 步正好从 s到达 e，每一次可以可以向左或者向右走(<strong>走过终点再往回走也行</strong>)，求方案数 MOD 1e9+7 的结果。<br><div class="tip warning faa-parent animated-hover"><p class="faa-horizontal">注意数轴可能有负数</p></div></p><h2 id="题意解析"><a href="#题意解析" class="headerlink" title="题意解析"></a>题意解析</h2><p>使用动态规划：</p><blockquote><ol><li><span class='p red'>dp[i][j]表示走了 i 步，当前位置在 j 的时候的方案数</span></li><li><span class='p red'>初始值 dp[0][s]=1</span></li><li><span class='p red'>状态转移方程：f[i][j] = f[i-1][j-1] + f[i-1][j+1]</span>，表示上一步从左到右和从右到左到达当前位置的方案数总和</li></ol></blockquote><div class="tip warning faa-parent animated-hover"><p class="faa-horizontal">考虑到负数，我们给起点和终点加一个偏移量</p></div><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numberOfWays</span><span class="params">(<span class="type">int</span> s, <span class="type">int</span> e, <span class="type">int</span> k)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> dp[<span class="number">1010</span>][<span class="number">2010</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> MOD=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line">        s+=<span class="number">500</span>; e+=<span class="number">500</span>; <span class="comment">//偏移量</span></span><br><span class="line">        dp[<span class="number">0</span>][s]=<span class="number">1</span>; <span class="comment">//初始化</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=k;i++) <span class="comment">//一共只能走 k 步</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;<span class="number">2005</span>;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                dp[i][j]+=dp[i<span class="number">-1</span>][j<span class="number">-1</span>]; <span class="comment">//从右走到达当前位置</span></span><br><span class="line">                dp[i][j]=(dp[i][j]+dp[i<span class="number">-1</span>][j+<span class="number">1</span>])%MOD; <span class="comment">//从左走到达当前位置</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[k][e];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 每日一题--队列队 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>力扣第86场双周赛---第三题</title>
      <link href="/posts/73d80173.html"/>
      <url>/posts/73d80173.html</url>
      
        <content type="html"><![CDATA[<div class="tag link"><a class="link-card" title="力扣 6173. 被列覆盖的最多行数" href="https://leetcode.cn/problems/maximum-rows-covered-by-columns/"><div class="left"><img src="https://img.hipyt.cn/imgs/2022/09/e3f773cfe32f6f4f.jpg"/></div><div class="right"><p class="text">力扣 6173. 被列覆盖的最多行数</p><p class="url">https://leetcode.cn/problems/maximum-rows-covered-by-columns/</p></div></a></div><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>给出一个 n 行 m 列的二维二进制矩阵(只有 0 和 1 两个数)，再给出一个数 cols 表示你<strong>一共要选出 cols 列</strong>。对于每一行，如果<span class='p red'>这一行中的所有 1 都在你选中的列中</span>，那么称此行被覆盖。问：最多能有多少行被覆盖。</p><h2 id="题意解析"><a href="#题意解析" class="headerlink" title="题意解析"></a>题意解析</h2><div class="tip key"><p>二进制枚举</p></div><p>题目数据很小，矩阵最多 12 X 12 ，因此我们可以使用二进制枚举来完成此题。</p><blockquote><p>对于某一个矩阵列数为 m ，如果我们可以选择任意列数，那么通过高中学习的排列组合知识，我们可以得到 C<sub>m</sub><sup style="margin-left:-10px">1</sup> 一直加到 C<sub>m</sub><sup style="margin-left:-10px">m</sup> 种选择，也就是 2<sup>m</sup> 种选择，也正好对应了 0 到 2<sup>m</sup> 的二进制表示(<strong>0 表示不选择，1 表示选择</strong>)。</p><p> 我们再通过处理过滤掉二进制表示中 1 的个数不等于 cols 的情况，然后再带入矩阵中，找到哪一种选择的覆盖层数最大即可。</p></blockquote><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lowbit</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;<span class="comment">//计算某个数的二进制表示中 1 的个数</span></span><br><span class="line">        <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(x)</span><br><span class="line">        &#123;</span><br><span class="line">            ans++;</span><br><span class="line">            x-=x&amp;-x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maximumRows</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; mat, <span class="type">int</span> cols)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> n=mat.<span class="built_in">size</span>(),m=mat[<span class="number">0</span>].<span class="built_in">size</span>(); <span class="comment">//n行，m列</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// cout&lt;&lt;n&lt;&lt;&#x27; &#x27;&lt;&lt;m&lt;&lt;endl;</span></span><br><span class="line">        <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">1</span>&lt;&lt;m;i++)</span><br><span class="line">        &#123;<span class="comment">//枚举所有选择</span></span><br><span class="line">            <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">lowbit</span>(i)!=cols) <span class="keyword">continue</span>;<span class="comment">//过滤掉不符合情况的选择</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">            &#123;<span class="comment">//对于某一种情况，遍历矩阵判断覆盖层数</span></span><br><span class="line">                <span class="type">bool</span> flag=<span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;m;k++)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">//对于某一层，如果有一列是 1，但是我们这一列没有选择，那么我们这一层就没有被覆盖</span></span><br><span class="line">                    <span class="keyword">if</span>(mat[j][k]&amp;&amp;(i&gt;&gt;k&amp;<span class="number">1</span>)==<span class="number">0</span>) flag=<span class="literal">false</span>;</span><br><span class="line">                    <span class="comment">// cout&lt;&lt;mat[j][k]&lt;&lt;&#x27; &#x27;&lt;&lt;(i&gt;&gt;k&amp;1)&lt;&lt;&#x27; &#x27;&lt;&lt;flag&lt;&lt;endl;</span></span><br><span class="line">                &#125;</span><br><span class="line">                res+=flag;</span><br><span class="line">                <span class="comment">// cout&lt;&lt;endl;</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// cout&lt;&lt;res&lt;&lt;&#x27; &#x27;;</span></span><br><span class="line">            ans=<span class="built_in">max</span>(ans,res);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 力扣周赛 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二进制枚举 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>力扣第86场双周赛---第二题</title>
      <link href="/posts/3ec6a221.html"/>
      <url>/posts/3ec6a221.html</url>
      
        <content type="html"><![CDATA[<div class="tag link"><a class="link-card" title="力扣 6172. 严格回文的数字" href="https://leetcode.cn/problems/strictly-palindromic-number/"><div class="left"><img src="https://img.hipyt.cn/imgs/2022/09/e3f773cfe32f6f4f.jpg"/></div><div class="right"><p class="text">力扣 6172. 严格回文的数字</p><p class="url">https://leetcode.cn/problems/strictly-palindromic-number/</p></div></a></div><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>将一个数 n 转化为 b 进制(b 为 2 到 n-2 的整数)，如果在 b 进制下 n 都是回文字符串，那么 n 是严格回文的。是则返回 true；否则返回 false。</p><h2 id="题意解析"><a href="#题意解析" class="headerlink" title="题意解析"></a>题意解析</h2><p>直接将 n 的每一个 b 进制表示出来，在一个个判断是否回文，可以枚举。<br><div class="tip info"><p>知识点：进制转换</p></div></p><blockquote><p>这个题目涉及到的就是进制转换，如何将十进制的 n 转换为其他进制？<br>我们需要用除 b 取余法。简单来说，我们将 n%b，将余数保存在数组，再将 n/b。不断地从重复上述操作，最后保存的数组就是将十进制转化的 b 进制数。<br>需要注意的是：<strong>保存的进制数是从左到右看的，而正常的进制数都是从右到左</strong>。</p></blockquote><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">zh</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">while</span>(n)</span><br><span class="line">        &#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(n%b);</span><br><span class="line">            n/=b;</span><br><span class="line">        &#125;<span class="comment">//将 n 转换为 b 进制数，除 b 取余法</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;ans.<span class="built_in">size</span>()/<span class="number">2</span>;i++)</span><br><span class="line">        &#123;<span class="comment">//因为判断回文，正反看都是一样的，所以这里进制数不需要处理</span></span><br><span class="line">            <span class="keyword">if</span>(ans[i]!=ans[ans.<span class="built_in">size</span>()-i<span class="number">-1</span>]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isStrictlyPalindromic</span><span class="params">(<span class="type">int</span> n)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n<span class="number">-2</span>;i++)</span><br><span class="line">        &#123;<span class="comment">//遍历判断回文即可</span></span><br><span class="line">            <span class="keyword">if</span>(!<span class="built_in">zh</span>(n,i)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 力扣周赛 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 进制转换 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>力扣第86场双周---第一题</title>
      <link href="/posts/64bab674.html"/>
      <url>/posts/64bab674.html</url>
      
        <content type="html"><![CDATA[<div class="tag link"><a class="link-card" title="力扣 6171. 和相等的子数组" href="https://leetcode.cn/problems/find-subarrays-with-equal-sum/"><div class="left"><img src="https://img.hipyt.cn/imgs/2022/09/e3f773cfe32f6f4f.jpg"/></div><div class="right"><p class="text">力扣 6171. 和相等的子数组</p><p class="url">https://leetcode.cn/problems/find-subarrays-with-equal-sum/</p></div></a></div><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>判断在一个数组 nums 中，是否存在两个长度为 2 的子数组且它们的和相等，存在则返回 true，否则返回 false。</p><h2 id="题意解析"><a href="#题意解析" class="headerlink" title="题意解析"></a>题意解析</h2><p>我们直接使用哈希表，遍历每个长度为 2 的子数组，其和对应的键值加一，直到存在某个键值大于一。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">findSubarrays</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">bool</span> flag=<span class="literal">false</span>;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; mp; <span class="comment">//哈希表</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>()<span class="number">-1</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            mp[nums[i]+nums[i+<span class="number">1</span>]]++;</span><br><span class="line">            <span class="keyword">if</span>(mp[nums[i]+nums[i+<span class="number">1</span>]]&gt;<span class="number">1</span>) <span class="comment">//存在至少两个</span></span><br><span class="line">            &#123;</span><br><span class="line">                flag=<span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> flag;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 力扣周赛 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 哈希表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2022-09-03未来可期小组每日一题</title>
      <link href="/posts/91dbe174.html"/>
      <url>/posts/91dbe174.html</url>
      
        <content type="html"><![CDATA[<div class="tag link"><a class="link-card" title="acwing 1681. 谷仓刷漆" href="https://www.acwing.com/problem/content/1683/"><div class="left"><img src="https://img.hipyt.cn/imgs/2022/09/e3f773cfe32f6f4f.jpg"/></div><div class="right"><p class="text">acwing 1681. 谷仓刷漆</p><p class="url">https://www.acwing.com/problem/content/1683/</p></div></a></div><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>约翰给一个二维平面刷油漆，一共刷 n 次，每次刷的面积是一个矩形，会给出左下角和右上角的点的坐标来表示。在给出一个数 k，问 n 次刷漆过后被刷过 k 次漆的面积有多大。</p><h2 id="题意解析"><a href="#题意解析" class="headerlink" title="题意解析"></a>题意解析</h2><p>这个题目很明显要用到二维差分和二维前缀和的知识，我们将每一次刷过的矩形中的每个数加一，最后遍历整个二维平面，计算有多少个数等于 k 就行。<br><div class="tip key"><p>细节方面</p></div></p><blockquote><ol><li>由于题目给的是坐标轴上的坐标，就”相当于”二维数组的左上角和右下角，所以不用变换坐标</li><li>由于给的是点的坐标，我们需要的是格子的坐标，所以需要将给出的左下角的坐标加一</li><li><a href="https://www.acwing.com/solution/content/27325/">差分矩阵</a></li></ol></blockquote><h2 id="代码-c"><a href="#代码-c" class="headerlink" title="代码(c++)"></a>代码(c++)</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1010</span>;</span><br><span class="line"><span class="type">int</span> a[N][N],b[N][N];</span><br><span class="line"><span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> x1,<span class="type">int</span> y1,<span class="type">int</span> x2,<span class="type">int</span> y2,<span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    b[x1][y1]+=c;</span><br><span class="line">    b[x1][y2+<span class="number">1</span>]-=c;</span><br><span class="line">    b[x2+<span class="number">1</span>][y1]-=c;</span><br><span class="line">    b[x2+<span class="number">1</span>][y2+<span class="number">1</span>]+=c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,k;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> max_x=<span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> x1,y1,x2,y2;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;x1&gt;&gt;y1&gt;&gt;x2&gt;&gt;y2;</span><br><span class="line">        <span class="built_in">insert</span>(x1+<span class="number">1</span>,y1+<span class="number">1</span>,x2,y2,<span class="number">1</span>);  <span class="comment">//因为给的点是坐标，我们用差分计算面积(格子数量)，所以需要加一</span></span><br><span class="line">        max_x=<span class="built_in">max</span>(max_x,<span class="built_in">max</span>(<span class="built_in">max</span>(x1+<span class="number">1</span>,x2+<span class="number">1</span>),<span class="built_in">max</span>(y1+<span class="number">1</span>,y2+<span class="number">1</span>)));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=max_x;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=max_x;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            b[i][j]+=b[i][j<span class="number">-1</span>]+b[i<span class="number">-1</span>][j]-b[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">            <span class="keyword">if</span>(b[i][j]==k) ans++;</span><br><span class="line">            <span class="comment">// cout&lt;&lt;b[i][j]&lt;&lt;&#x27; &#x27;;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// cout&lt;&lt;endl;</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 每日一题--未来可期小组 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二维前缀和 </tag>
            
            <tag> 二维差分 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2022-09-03队列队每日一题</title>
      <link href="/posts/6f46db02.html"/>
      <url>/posts/6f46db02.html</url>
      
        <content type="html"><![CDATA[<div class="tag link"><a class="link-card" title="力扣 646. 最长数对链" href="https://leetcode.cn/classic/problems/maximum-length-of-pair-chain/description/"><div class="left"><img src="https://img.hipyt.cn/imgs/2022/09/e3f773cfe32f6f4f.jpg"/></div><div class="right"><p class="text">力扣 646. 最长数对链</p><p class="url">https://leetcode.cn/classic/problems/maximum-length-of-pair-chain/description/</p></div></a></div><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>给出 n 个数对，设 [a,b] , [c,d] (<strong>a&lt;b，c&lt;d</strong>)为一对数对，<span class='p red'>当且仅当 b < c 的时候，这两个数对可以形成数对链</span>，数对可以以任意顺序排列，<strong>求出最长的序列对(不必使用所有的数对)</strong>。(1&lt;=n&lt;=1000)</p><h2 id="题意解析"><a href="#题意解析" class="headerlink" title="题意解析"></a>题意解析</h2><p>首先附上<a href="https://leetcode.cn/problems/maximum-length-of-pair-chain/solution/zui-chang-shu-dui-lian-by-leetcode-solut-ifpn/">官方题解</a></p><p>这个题目与力扣的<a href="https://leetcode.cn/problems/longest-increasing-subsequence/">300. 最长递增子序列</a>的题目所使用的方法类似，可以使用动态规划<sup><a href="#fn_1" id="reffn_1">1</a></sup>的方法解决。<br><div class="tip info"><p>图片写法参考自<a href="https://www.acwing.com/video/327/">https://www.acwing.com/video/327/</a> </p></div><br><div class="img-wrap"><div class="img-bg"><img class="img" src="https://img.hipyt.cn/imgs/2022/09/01f559874e4e9f0e.jpg"/></div></div></p><p>对于当前第 i 个数对，如果可以和之前的某一个数对 j 形成数对链，那么 dp[i] 就可以更新为 dp[i] 和 dp[j]+1 的较大值。(<strong>dp[j]+1 表示前面的数对链加上当前数对的个数</strong>)<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if(p[i][0]&gt;p[j][1])</span><br><span class="line">&#123;</span><br><span class="line">    dp[i]=max(dp[i],dp[j]+1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findLongestChain</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; p)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(p.<span class="built_in">begin</span>(),p.<span class="built_in">end</span>()); <span class="comment">//考虑到题目说的任意顺序，这里一定要排序</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(p.size())</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;p.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i]=<span class="number">1</span>; <span class="comment">//其本身也算一个</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=i;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(p[i][<span class="number">0</span>]&gt;p[j][<span class="number">1</span>])</span><br><span class="line">                &#123;<span class="comment">//如果当前数对可以加在前面的数对链后面</span></span><br><span class="line">                    dp[i]=<span class="built_in">max</span>(dp[i],dp[j]+<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> ans=<span class="number">0</span>;<span class="comment">//求出最大值</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> x : dp) ans=<span class="built_in">max</span>(ans,x);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote id="fn_1"><sup>1</sup>. 通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法。<a href="#reffn_1" title="Jump back to footnote [1] in the text."> &#8617;</a></blockquote>]]></content>
      
      
      <categories>
          
          <category> 每日一题--队列队 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
            <tag> 线性dp </tag>
            
            <tag> 最长上升子序列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2022-09-02未来可期小组每日一题</title>
      <link href="/posts/9f3c09a5.html"/>
      <url>/posts/9f3c09a5.html</url>
      
        <content type="html"><![CDATA[<div class="tag link"><a class="link-card" title="acwing 1680. 困牛放牧" href="https://www.acwing.com/problem/content/1682/"><div class="left"><img src="https://img.hipyt.cn/imgs/2022/09/e3f773cfe32f6f4f.jpg"/></div><div class="right"><p class="text">acwing 1680. 困牛放牧</p><p class="url">https://www.acwing.com/problem/content/1682/</p></div></a></div><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>有 n 头牛，随机分布在一条坐标轴上，每一次可以令一头最左或最右(左右端点)的牛移动到<strong>任意两头牛中间(不能移动到端点)</strong>，最终让所有的牛在坐标轴上连续，输出移动的最大次数和最小次数。</p><h2 id="题意解析"><a href="#题意解析" class="headerlink" title="题意解析"></a>题意解析</h2><p><strong>首先先对这堆数据进行排序，然后我们分别求出最大值和最小值</strong></p><div class="tabs" id=""><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#-1">最大值</button></li><li class="tab"><button type="button" data-href="#-2">最小值</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="-1"><p>对于最大值，显然我们一个一个的移动，移动次数是最大的。但是第一步一定是移动左右两个端点，所以我们一定会失去<b>第一个点到第二个点之间的距离</b>或者<b>倒数一个点到倒数二个点之间的距离</b>，因此我们计算<b>第二个点到最后一个点的距离和第一个点到倒数第二个点的距离谁大就行</b></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="-2"><p>对于最小值，我们不管怎么移动，到最后一定会是一个长度为 n 的序列，因此，我们可以选择遍历每一段 n 长度的线段，找出奶牛最多的那一段，也就是需要移动的次数最少的那一段。</p><div class="tip warning faa-parent animated-hover"><p class="faa-horizontal">需要注意的是，如果除了第一个点或者最后一个点，其他点全部都相邻，那么只需要两步就可以解决</p></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="代码-c"><a href="#代码-c" class="headerlink" title="代码(c++)"></a>代码(c++)</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> ans_min,ans_max;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) cin&gt;&gt;a[i];</span><br><span class="line">    <span class="built_in">sort</span>(a,a+n);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//最小值</span></span><br><span class="line">    <span class="comment">//如果等于二，可以将另外一边的端点移动到空里，只需一步</span></span><br><span class="line">    <span class="comment">//例如:3，4，5，6，8 ，直接将 3 移动到 7 的位置</span></span><br><span class="line">    <span class="keyword">if</span>((a[n<span class="number">-1</span>]-a[n<span class="number">-2</span>]&gt;<span class="number">2</span>&amp;&amp;a[n<span class="number">-2</span>]-a[<span class="number">0</span>]==n<span class="number">-2</span>)||(a[<span class="number">1</span>]-a[<span class="number">0</span>]&gt;<span class="number">2</span>&amp;&amp;a[n<span class="number">-1</span>]-a[<span class="number">1</span>]==n<span class="number">-2</span>)) ans_min=<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> cow_max=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//利用双指针求出在每一段 n 内有多少头牛</span></span><br><span class="line">            <span class="keyword">while</span>(j&lt;n<span class="number">-1</span>&amp;&amp;a[j+<span class="number">1</span>]-a[i]&lt;=n<span class="number">-1</span>) j++;</span><br><span class="line">            cow_max=<span class="built_in">max</span>(cow_max,j-i+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        ans_min=n-cow_max;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 最大值</span></span><br><span class="line">    ans_max=<span class="built_in">max</span>(a[n<span class="number">-2</span>]-a[<span class="number">0</span>],a[n<span class="number">-1</span>]-a[<span class="number">1</span>])-n+<span class="number">2</span>;</span><br><span class="line">    </span><br><span class="line">    cout&lt;&lt;ans_min&lt;&lt;endl&lt;&lt;ans_max&lt;&lt;endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 每日一题--未来可期小组 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技巧题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2022-09-02队列队每日一题</title>
      <link href="/posts/786ebfc2.html"/>
      <url>/posts/786ebfc2.html</url>
      
        <content type="html"><![CDATA[<div class="tag link"><a class="link-card" title="力扣1545. 找出第 N 个二进制字符串中的第 K 位" href="https://leetcode.cn/problems/find-kth-bit-in-nth-binary-string/"><div class="left"><img src="https://img.hipyt.cn/imgs/2022/09/e3f773cfe32f6f4f.jpg"/></div><div class="right"><p class="text">力扣1545. 找出第 N 个二进制字符串中的第 K 位</p><p class="url">https://leetcode.cn/problems/find-kth-bit-in-nth-binary-string/</p></div></a></div><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>给你一个 n 和 k 数，输出 S~n~的第 k 的字母；</p><blockquote><ol><li>S<sub>1</sub> = “0”；</li><li>对于 S<sub>i</sub> (<strong>i&gt;1</strong>)，S<sub>i</sub> = S<sub>i-1</sub> + “1” + 反转和颠倒的 S<sub>i-1</sub>；</li></ol></blockquote><div class="tip warning faa-parent animated-hover"><p class="faa-horizontal">反转指将每一位的 "0"变"1"，"1"变"0"；颠倒指将字符串反过来</p></div><h2 id="题意解析"><a href="#题意解析" class="headerlink" title="题意解析"></a>题意解析</h2><p>这个题目因为 n 只有 20，所以如果用暴力的方法也可以做出来，另一种方法是递归，接下来详细讲述递归的方法。</p><blockquote><ol><li>对于一个 n，我们通过数学归纳可以得到<strong> S<sub>n</sub> 的长度为 2<sup>n</sup>-1</strong>。</li><li>由题目可以知道，如果 k 正好等于 2<sup>n-1</sup>，也就是正中间那个 1，那么可以直接返回 1；</li><li>其次，当 k &lt; 2<sup>n-1</sup>，那么 k 就在 S<sub>n-1</sub> 里面找，也就是 S<sub>n</sub> 的前半段</li><li>最后，当 k &gt; 2<sup>n-1</sup>，那么 k 就在 S<sub>n</sub> 的后半段里面找。此处，第 k 个字符也就是从右往左的第 2<sup>n</sup>-k 个字符，然后反转一下</li></ol></blockquote><h2 id="代码-c-暴力版"><a href="#代码-c-暴力版" class="headerlink" title="代码(c++) 暴力版"></a>代码(c++) 暴力版</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">char</span> <span class="title">findKthBit</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>) <span class="keyword">return</span> <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        string s1;</span><br><span class="line">        s1=<span class="string">&quot;0&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            string str=s1;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;x : str) x^=<span class="number">1</span>;   <span class="comment">//用 str 存储反转后的 s1</span></span><br><span class="line">            <span class="built_in">reverse</span>(str.<span class="built_in">begin</span>(),str.<span class="built_in">end</span>());  <span class="comment">//颠倒</span></span><br><span class="line">            s1+=<span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">            s1+=str;   <span class="comment">//相加</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s1[k<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="代码-c-递归版"><a href="#代码-c-递归版" class="headerlink" title="代码(c++) 递归版"></a>代码(c++) 递归版</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">char</span> <span class="title">findKthBit</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(k==<span class="number">1</span>) <span class="keyword">return</span> <span class="string">&#x27;0&#x27;</span>; <span class="comment">//当 k 等于 1 的时候，一定是 0</span></span><br><span class="line">        <span class="type">int</span> z=<span class="number">1</span>&lt;&lt;(n<span class="number">-1</span>);    <span class="comment">//记录 Sn 中间那个一的位置</span></span><br><span class="line">        <span class="keyword">if</span>(k==z) <span class="keyword">return</span> <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(k&gt;z) <span class="keyword">return</span> <span class="built_in">findKthBit</span>(n<span class="number">-1</span>,(<span class="number">1</span>&lt;&lt;n)-k)^<span class="number">1</span>; <span class="comment">//如果大于，则从右往左找，^1 将其反转</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">findKthBit</span>(n<span class="number">-1</span>,k);   <span class="comment">//同理，不用反转    </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 每日一题--队列队 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 递归 </tag>
            
            <tag> 暴力 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2022-09-01未来可期小组每日一题</title>
      <link href="/posts/8c1430d6.html"/>
      <url>/posts/8c1430d6.html</url>
      
        <content type="html"><![CDATA[<hr><h2 id=""><a href="#" class="headerlink" title=""></a><div class="tag link"><a class="link-card" title="acwing 1685. 测量测量" href="https://www.acwing.com/problem/content/1687/"><div class="left"><img src="https://img.hipyt.cn/imgs/2022/09/e3f773cfe32f6f4f.jpg"/></div><div class="right"><p class="text">acwing 1685. 测量测量</p><p class="url">https://www.acwing.com/problem/content/1687/</p></div></a></div></h2><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>有一个 n 英里的路，一个人在每一英里的路上放一个探测器记录车流量，这个探测器只能记录大概的范围，如果这一英里的路有匝道出口，则探测器<strong>放在出口</strong>，入口同理；</p><blockquote><ol><li>输入 n</li><li>每行有三个数据，第一个是字符：”none”表示没有出入口；”off”表示有出口；”on”表示有入口</li><li>要求输出这条 n 英里的路之前和之后的车流量范围</li></ol></blockquote><h2 id="题意解析"><a href="#题意解析" class="headerlink" title="题意解析"></a>题意解析</h2><ol><li>首先看 n 英里之后，我们先用 <strong>l，r 表示范围，l[i]，r[i]表示探测的数据</strong>，我们从头遍历每一个数据，如果遇到入口，则我们在 l 和 r 上加上相应的数值，<strong>即范围更新为：[ l+l[i]，r+r[i] ]</strong>；<strong>要注意的是</strong>，如果是出口，则应该让 l 减去 r[i]，因为我们要保证数据更加的精准<strong>即范围更新为：[ l-r[i]，r-l[i] ]</strong>；如果没有出入口，则 l 与 l[i]取最大，r 与 r[i]取最小<strong>即范围更新为：[ max(l,l[i])，min(r,r[i]) ]</strong>。</li><li>然后看 1 英里之前，大致方法同上，区别在于<strong>我们从尾遍历到头</strong></li></ol><h2 id="代码-c"><a href="#代码-c" class="headerlink" title="代码(c++)"></a>代码(c++)</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> l[<span class="number">110</span>],r[<span class="number">110</span>];</span><br><span class="line">string s[<span class="number">110</span>];</span><br><span class="line"><span class="type">int</span> n; </span><br><span class="line"><span class="type">int</span> l_s=<span class="number">0</span>,r_s=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">int</span> l_e=<span class="number">0</span>,r_e=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) cin&gt;&gt;s[i]&gt;&gt;l[i]&gt;&gt;r[i];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)  <span class="comment">//从尾到头</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i]==<span class="string">&quot;none&quot;</span>) l_s=<span class="built_in">max</span>(l_s,l[i]),r_s=<span class="built_in">min</span>(r_s,r[i]);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(s[i]==<span class="string">&quot;on&quot;</span>) l_s-=r[i],r_s-=l[i];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(s[i]==<span class="string">&quot;off&quot;</span>) l_s+=l[i],r_s+=r[i];</span><br><span class="line">    &#125;</span><br><span class="line">    l_s=<span class="built_in">max</span>(<span class="number">0</span>,l_s); r_s=<span class="built_in">max</span>(<span class="number">0</span>,r_s); <span class="comment">//要注意有肯能有可能小于零</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)  <span class="comment">//从头到尾</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i]==<span class="string">&quot;none&quot;</span>) l_e=<span class="built_in">max</span>(l_e,l[i]),r_e=<span class="built_in">min</span>(r_e,r[i]);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(s[i]==<span class="string">&quot;on&quot;</span>) l_e+=l[i],r_e+=r[i];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(s[i]==<span class="string">&quot;off&quot;</span>) l_e-=r[i],r_e-=l[i];</span><br><span class="line">    &#125;</span><br><span class="line">    l_e=<span class="built_in">max</span>(<span class="number">0</span>,l_e); r_e=<span class="built_in">max</span>(<span class="number">0</span>,r_e);</span><br><span class="line">    </span><br><span class="line">    cout&lt;&lt;l_s&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;r_s&lt;&lt;endl&lt;&lt;l_e&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;r_e&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 每日一题--未来可期小组 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技巧题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2022-09-01队列队每日一题</title>
      <link href="/posts/41161282.html"/>
      <url>/posts/41161282.html</url>
      
        <content type="html"><![CDATA[<hr><h2 id=""><a href="#" class="headerlink" title=""></a><div class="tag link"><a class="link-card" title="力扣 1475. 商品折扣后的最终价格" href="https://leetcode.cn/problems/final-prices-with-a-special-discount-in-a-shop/"><div class="left"><img src="https://img.hipyt.cn/imgs/2022/09/e3f773cfe32f6f4f.jpg"/></div><div class="right"><p class="text">力扣 1475. 商品折扣后的最终价格</p><p class="url">https://leetcode.cn/problems/final-prices-with-a-special-discount-in-a-shop/</p></div></a></div></h2><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>给出一个数组，对于每一个数 prices[i]，找到它右边第一个比它小的数 prices[j]，然后让这个数减去 prices[j]，否则就不变。</p><h2 id="题意解析"><a href="#题意解析" class="headerlink" title="题意解析"></a>题意解析</h2><p>有一种单调栈的做法。<a href="https://blog.csdn.net/lucky52529/article/details/89155694">单调栈</a>是一种数据结构。对于这个题，题目要求是找到这个数右边第一个比它小的数字，我们可以<strong>从右到左</strong>遍历这个数组，让数据<strong>从栈低到栈顶依次递增</strong>。<br>这个时候我们会遇到三种情况:</p><blockquote><ol><li>当前元素比栈顶元素小；我们依次弹出栈顶元素(<strong>此时栈顶元素会越来越小</strong>)，直到遇到第一个比自己小的元素，并记录当前元素减去栈顶元素的值，然后将当前元素入栈</li><li>当前元素比栈顶元素大；我们直接记录当前元素减去栈顶元素的值，然后将当前元素入栈</li><li>当栈为空时，记录当前元素的值，入栈</li></ol></blockquote><h2 id="代码-c"><a href="#代码-c" class="headerlink" title="代码(c++)"></a>代码(c++)</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">finalPrices</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; s;</span><br><span class="line">        <span class="comment">//可以直接倒序遍历，如果反转了数组，答案数组也是反的</span></span><br><span class="line">        <span class="built_in">reverse</span>(prices.<span class="built_in">begin</span>(),prices.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> x : prices)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(s.<span class="built_in">size</span>()&amp;&amp;s.<span class="built_in">top</span>()&gt;x) s.<span class="built_in">pop</span>();</span><br><span class="line">            ans.<span class="built_in">push_back</span>(s.<span class="built_in">size</span>() ? x-s.<span class="built_in">top</span>() : x);</span><br><span class="line">            s.<span class="built_in">push</span>(x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">reverse</span>(ans.<span class="built_in">begin</span>(),ans.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 每日一题--队列队 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 单调栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2022-08-31队列队每日一题</title>
      <link href="/posts/9278bbb1.html"/>
      <url>/posts/9278bbb1.html</url>
      
        <content type="html"><![CDATA[<hr><h2 id=""><a href="#" class="headerlink" title=""></a><div class="tag link"><a class="link-card" title="力扣 946.验证栈序列" href="https://leetcode.cn/problems/validate-stack-sequences/"><div class="left"><img src="https://img.hipyt.cn/imgs/2022/09/e3f773cfe32f6f4f.jpg"/></div><div class="right"><p class="text">力扣 946.验证栈序列</p><p class="url">https://leetcode.cn/problems/validate-stack-sequences/</p></div></a></div></h2><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>我们将<strong>pushed</strong>里面的数压栈，在压栈的同时如果与<strong>popped</strong>里面的数值相同，则出栈，看最后<strong>是否能够全部出出栈</strong></p><h2 id="题意解析"><a href="#题意解析" class="headerlink" title="题意解析"></a>题意解析</h2><p>题目的目的是判断是否能够全部出栈，我们直接<strong>先将poped数组的数字反过来压栈，再将pushed数组的数字一个一个入栈并且将栈顶的数字进行比较，出栈直到两个栈的栈顶不同</strong></p><h2 id="代码-c"><a href="#代码-c" class="headerlink" title="代码(c++)"></a>代码(c++)</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">validateStackSequences</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; pu, vector&lt;<span class="type">int</span>&gt;&amp; po)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; s1,s2; </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=po.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--) s2.<span class="built_in">push</span>(po[i]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;pu.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            s1.<span class="built_in">push</span>(pu[i]);</span><br><span class="line">            <span class="keyword">while</span>(s1.<span class="built_in">size</span>()&amp;&amp;s1.<span class="built_in">top</span>()==s2.<span class="built_in">top</span>()) s1.<span class="built_in">pop</span>(),s2.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> !s2.<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 每日一题--队列队 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 栈 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2022-08-31未来可期小组每日一题</title>
      <link href="/posts/e42af308.html"/>
      <url>/posts/e42af308.html</url>
      
        <content type="html"><![CDATA[<hr><h2 id=""><a href="#" class="headerlink" title=""></a><div class="tag link"><a class="link-card" title="acwing 1684. 大型植被恢复" href="https://www.acwing.com/problem/content/1686/"><div class="left"><img src="https://img.hipyt.cn/imgs/2022/09/e3f773cfe32f6f4f.jpg"/></div><div class="right"><p class="text">acwing 1684. 大型植被恢复</p><p class="url">https://www.acwing.com/problem/content/1686/</p></div></a></div></h2><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>有 n 个点和 m 条边，有四种颜色对每个点进行染色，每个点 <strong>最多能连接三条边</strong>，一条边的两个点<strong>不能染成相同的颜色</strong>，请输出<strong>字典序最小</strong>的染色方法</p><h2 id="题意解析"><a href="#题意解析" class="headerlink" title="题意解析"></a>题意解析</h2><p>我们对每个点使用<strong>邻接表建边</strong>，用<strong>st</strong>数组进行标记，然后从遍历每个点，每个点染色后，其对应的另一个点就删去这个颜色，因为有四种颜色，每个点最多三条边，故<strong>一次遍历就能够得出答案</strong></p><h2 id="代码-c"><a href="#代码-c" class="headerlink" title="代码(c++)"></a>代码(c++)</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> h[<span class="number">110</span>],e[<span class="number">310</span>],ne[<span class="number">310</span>],idx;</span><br><span class="line"><span class="type">bool</span> st[<span class="number">110</span>][<span class="number">5</span>];</span><br><span class="line"><span class="type">int</span> ans[<span class="number">110</span>];</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx]=b; ne[idx]=h[a]; h[a]=idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a,b;</span><br><span class="line">        cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">        <span class="built_in">add</span>(a,b),<span class="built_in">add</span>(b,a);<span class="comment">//建边，把牛当成边，草地当成点</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123; <span class="comment">//遍历每一个点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=<span class="number">4</span>;j++)</span><br><span class="line">        &#123;<span class="comment">//从头开始遍历，确保是最小字典序</span></span><br><span class="line">            <span class="keyword">if</span>(!st[i][j])</span><br><span class="line">            &#123;</span><br><span class="line">                ans[i]=j; </span><br><span class="line">                <span class="comment">//如果这种草能够选择，那么与这个点有边的点都不能选这种草</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k=h[i];~k;k=ne[k]) st[e[k]][j]=<span class="number">1</span>;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) cout&lt;&lt;ans[i];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 每日一题--未来可期小组 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 邻接表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/posts/4a17b156.html"/>
      <url>/posts/4a17b156.html</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title>分类</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>标签</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/css/custom.css"/>
      <url>/css/custom.css</url>
      
        <content type="html"><![CDATA[/* @font-face {  font-family: Candyhome;  src: url(https://cdn.cbd.int/anzhiyu-blog@1.1.6/fonts/Candyhome.ttf);  font-display: swap;  font-weight: lighter;} */@font-face {  font-family: ZhuZiAYuanJWD;  src: url(https://cdn.cbd.int/anzhiyu-blog@1.1.6/fonts/ZhuZiAWan.woff2);  font-display: swap;  font-weight: lighter;}div#menus {  font-family: 'ZhuZiAYuanJWD';}h1#site-title {  font-family: ZhuZiAYuanJWD;  font-size: 3em !important;}a.article-title,a.blog-slider__title,a.categoryBar-list-link,h1.post-title {  font-family: ZhuZiAYuanJWD;}.iconfont {  font-family: 'iconfont' !important;  font-size: 3em;  /* 可以定义图标大小 */  font-style: normal;  -webkit-font-smoothing: antialiased;  -moz-osx-font-smoothing: grayscale;}/* 时间轴生肖icon */svg.icon {  /* 这里定义svg.icon，避免和Butterfly自带的note标签冲突 */  width: 1em;  height: 1em;  /* width和height定义图标的默认宽度和高度*/  vertical-align: -0.15em;  fill: currentColor;  overflow: hidden;}.icon-zhongbiao::before {  color: #f7c768;}/* bilibli番剧插件 */.bangumi-active {  background: #dbecfe !important;  border-radius: 10px !important;}a.bangumi-tab:hover {  text-decoration: none !important;}.bangumi-button:hover {  background: #dbecfe !important;  border-radius: 10px !important;}a.bangumi-button.bangumi-nextpage:hover {  text-decoration: none !important;}.bangumi-button {  padding: 5px 10px !important;}a.bangumi-tab {  padding: 5px 10px !important;}svg.icon.faa-tada {  font-size: 1.1em;}/* 解决artitalk的图标问题 */#uploadSource > svg {  width: 1.19em;  height: 1.5em;}/*top-img黑色透明玻璃效果移除，不建议加，除非你执着于完全一图流或者背景图对比色明显 */#page-header:not(.not-top-img):before {  background-color: transparent !important;}/* 首页文章卡片 */#recent-posts > .recent-post-item {  background: rgba(255, 255, 255, 0.7);  backdrop-filter: blur(10px);}/* 首页侧栏卡片 */#aside-content .card-widget {  background: rgba(255, 255, 255, 0.7);  backdrop-filter: blur(20px);}/* 文章页面正文背景 */div#post {  background: rgba(255, 255, 255, 0.7);  backdrop-filter: blur(20px);}/* 分页页面 */div#page {  background: rgba(255, 255, 255, 0.7);  backdrop-filter: blur(20px);}/* 归档页面 */div#archive {  background: rgba(255, 255, 255, 0.7);  backdrop-filter: blur(20px);}/* 标签页面 */div#tag {  background: rgba(255, 255, 255, 0.7);  backdrop-filter: blur(20px);}/* 分类页面 */div#category {  background: rgba(255, 255, 255, 0.7);  backdrop-filter: blur(20px);}/*夜间模式伪类遮罩层透明*/[data-theme='dark'] #recent-posts > .recent-post-item {  background: #121212;}[data-theme='dark'] .card-widget {  background: #121212 !important;}[data-theme='dark'] div#post {  background: #121212 !important;}[data-theme='dark'] div#tag {  background: #121212 !important;}[data-theme='dark'] div#archive {  background: #121212 !important;}[data-theme='dark'] div#page {  background: #121212 !important;}[data-theme='dark'] div#category {  background: #121212 !important;}[data-theme='dark'] div#category {  background: transparent !important;}/* 页脚透明 */#footer {  background: transparent !important;}/* 头图透明 */#page-header {  background: transparent !important;}#rightside > div > button {  border-radius: 5px;}/* 滚动条 */::-webkit-scrollbar {  width: 10px;  height: 10px;}::-webkit-scrollbar-thumb {  background-color: #49b1f5;  border-radius: 2em;}::-webkit-scrollbar-corner {  background-color: transparent;}::-moz-selection {  color: #fff;  background-color: #49b1f5;}/* 音乐播放器 *//* .aplayer .aplayer-lrc {  display: none !important;} */.aplayer.aplayer-fixed.aplayer-narrow .aplayer-body {  left: -66px !important;  transition: all 0.3s;  /* 默认情况下缩进左侧66px，只留一点箭头部分 */}.aplayer.aplayer-fixed.aplayer-narrow .aplayer-body:hover {  left: 0 !important;  transition: all 0.3s;  /* 鼠标悬停是左侧缩进归零，完全显示按钮 */}.aplayer.aplayer-fixed {  z-index: 999999 !important;}/* 评论框  */.vwrap {  box-shadow: 2px 2px 5px #bbb;  background: rgba(255, 255, 255, 0.3);  border-radius: 8px;  padding: 30px;  margin: 30px 0px 30px 0px;}/* 设置评论框 */.vcard {  box-shadow: 2px 2px 5px #bbb;  background: rgba(255, 255, 255, 0.3);  border-radius: 8px;  padding: 30px;  margin: 30px 0px 0px 0px;}/* 鼠标图标 */body {  cursor: url('/img/x1.cur'), auto;}a,[type='button']:not(:disabled),[type='reset']:not(:disabled),[type='submit']:not(:disabled),button:not(:disabled) {  cursor: url('/img/x2.cur'), auto !important;}/* md网站下划线 */#article-container a:hover {  text-decoration: none !important;}#article-container #hpp_talk p img {  display: inline;}/* 404页面 */#error-wrap {  position: absolute;  top: 40%;  right: 0;  left: 0;  margin: 0 auto;  padding: 0 1rem;  max-width: 1000px;  transform: translate(0, -50%);}#error-wrap .error-content {  display: flex;  flex-direction: row;  justify-content: center;  align-items: center;  margin: 0 1rem;  height: 18rem;  border-radius: 8px;  background: var(--card-bg);  box-shadow: var(--card-box-shadow);  transition: all 0.3s;}#error-wrap .error-content .error-img {  box-flex: 1;  flex: 1;  height: 100%;  border-top-left-radius: 8px;  border-bottom-left-radius: 8px;  background-color: #49b1f5;  background-position: center;  background-size: cover;}#error-wrap .error-content .error-info {  box-flex: 1;  flex: 1;  padding: 0.5rem;  text-align: center;  font-size: 14px;  font-family: Titillium Web, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft JhengHei', 'Microsoft YaHei', sans-serif;}#error-wrap .error-content .error-info .error_title {  margin-top: -4rem;  font-size: 9em;}#error-wrap .error-content .error-info .error_subtitle {  margin-top: -3.5rem;  word-break: break-word;  font-size: 1.6em;}#error-wrap .error-content .error-info a {  display: inline-block;  margin-top: 0.5rem;  padding: 0.3rem 1.5rem;  background: var(--btn-bg);  color: var(--btn-color);}#body-wrap.error .aside-list {  display: flex;  flex-direction: row;  flex-wrap: nowrap;  bottom: 0px;  position: absolute;  padding: 1rem;  width: 100%;  overflow: scroll;}#body-wrap.error .aside-list .aside-list-group {  display: flex;  flex-direction: row;  flex-wrap: nowrap;  max-width: 1200px;  margin: 0 auto;}#body-wrap.error .aside-list .aside-list-item {  padding: 0.5rem;}#body-wrap.error .aside-list .aside-list-item img {  width: 100%;  object-fit: cover;  border-radius: 12px;}#body-wrap.error .aside-list .aside-list-item .thumbnail {  overflow: hidden;  width: 230px;  height: 143px;  background: var(--heo-card-bg);  display: flex;}#body-wrap.error .aside-list .aside-list-item .content .title {  -webkit-line-clamp: 2;  overflow: hidden;  display: -webkit-box;  -webkit-box-orient: vertical;  line-height: 1.5;  justify-content: center;  align-items: flex-end;  align-content: center;  padding-top: 0.5rem;  color: white;}#body-wrap.error .aside-list .aside-list-item .content time {  display: none;}/* 代码框主题 */#article-container figure.highlight {  border-radius: 10px;}]]></content>
      
    </entry>
    
    
  
</search>
